<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>信息安全数学基础实验</title>
      <link href="/2025/10/22/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/"/>
      <url>/2025/10/22/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>现在存在这么一个问题：</p><p>对于$a^e$，当e很大时，计算$a$的$n$次方表示将$n$个$a$乘在一起$:a^n=\underbrace{a\times a\cdotp\cdotp\cdotp\times a}_{\text{n个a相乘}}$。<br>然而当$a,n$太大的时侯，这种方法就不太。所以如何更快更有效的解决这种计算呢？</p><p>举个例子：对于$3^{12}$，我们知道：$a^{b+c}=a^b\cdot a^c$, $a^{2b}=a^b\cdot a^b=(a^b)^2$。如果我们知道$3^6$，两个$3^6$相乘$3^6<em>3^6=3^{12}$，是不是就可以更好的计算出幂。二进制取幂的想法是，我们将取幂的任务按照指数的 二进制表示来<em>*分割成更小的任务</em></em>。</p><p>所以有如下的方法：<br>分拆指数：$256 = 2^8$<br>分治计算：</p><ul><li>$7^1 \mod 13 = 7$</li><li>$7^2 \mod 13 = [(7^1 \mod 13) * (7^1 \mod 13)] \mod 13 = 10$</li><li>$7^4 \mod 13 = 9, 7^8 \mod 13 = 3, …$</li><li>$7^{256} \mod 13 = [(7^{128} \mod 13) * (7^{128} \mod 13)] \mod 13 = 9$<br>归并：$7^{256} \mod 13 = 9$</li></ul><p>但是现在又出现一个问题：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2025/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><ul><li><p><mark style="background: #FFF3A3A6;">数据</mark><br>是记录下来可以被鉴别的符号， 它是最原始的素材（如数字、文字、图像、符号等） ， 未被加工解释， 没有回答特定的问题。<br>数据的特点： <u>数据与其语义是不可分的</u></p></li><li><p><mark style="background: #FFF3A3A6;">数据库</mark>（ Database， 简称 DB）<br>长期储存在计算机内、有组织的、可共享的大量数据集合。</p></li><li><p><mark style="background: #FFF3A3A6;">数据库管理系统</mark>（DataBase Management System，DBMS）<br>一种能让用户定义、创建和维护数据库， 以及控制对数据库访问的软件系统。<br>DBMS组成： 查询处理器和存储管理器。<br>DBMS功能 ：数据库定义功能、数据操纵功能、数据库运行控制功能、数据库的恢复、数据字典<br><img src="/images/Pasted%20image%2020251015205044.png" alt></p></li><li><p>数据库系统（Database System，简称DBS）<br>指在计算机系统中引入数据库后的系统构成。<br>组成：<br>硬件系统、数据库集合、数据库管理系统及相关软件、数据库管理员（DBA）、用户</p></li></ul><p><img src="/images/Pasted%20image%2020251015201058.png" alt></p><p><strong><mark style="background: #FFB8EBA6;">DBS包括DB和DBMS!</mark></strong></p><h2 id="实体与表"><a href="#实体与表" class="headerlink" title="实体与表"></a>实体与表</h2><ul><li><p>实体<br>一个实体可以是一个人、一个事件或一个我们将要为其收集数据的物体。<br>每个实体都有某些称为属性的特征</p></li><li><p>表<br>表是二维结构，它包括行和列。一个表包括一组相关的实体——实体集。<br>每个表必须有一个属性或者一个属性复合体来唯一标识每一行。<br><img src="/images/Pasted%20image%2020251015210505.png" alt></p></li><li><p>数据列表<br>关系数据库使用表来组织数据元素<br>每一个表对应于一个应用实体集，而每行则代表实体的一个实体。（图书馆管理系统中图书实体集对应数据库中的Book表，该表中的每一行则代表不同的书。）<br>实体和实体之间的关系被抽象为联系。（例如：一个“图书表”的行标识符（书籍编号）出现在一个“借阅表”的行中，从而建立了借阅与图书之间的联系。）<br>这种表之间通过属性进行联系，构成了关系列表，是关系数据库</p></li></ul><h2 id="数据库系统组成构成"><a href="#数据库系统组成构成" class="headerlink" title="数据库系统组成构成"></a>数据库系统组成构成</h2><ul><li>模式结构<br>一个数据库只有一个模式。<br>3层模式体系结构：<br><mark style="background: #FFF3A3A6;">内模式</mark>：（只有一个）是数据物理结构和存储方式的描述，数据在数据库内部的表示方式。<br><mark style="background: #FFF3A3A6;">模式</mark>：（逻辑模式，概念模式，只有一个）数据的逻辑结构，数据之间的联系，所有用户的公共数据视图。<br><mark style="background: #FFF3A3A6;">外模式</mark>：（视图，可以有多个）用户看到的样子/数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述。</li></ul><p><img src="/images/Pasted%20image%2020251015212344.png" alt><br><img src="/images/Pasted%20image%2020251015213514.png" alt><br>举个形象的例子：</p><pre><code>内模式（物理存储）:图书在书架上的实际摆放方式图书索引卡片的物理存储借阅记录的存储文件格式模式（整体设计）:图书信息表（书名、作者、ISBN、出版社）读者信息表（姓名、学号、联系方式）借阅记录表（借书时间、还书时间）这些表之间的关系外模式（用户视图）:学生看到的：可借图书列表、个人借阅记录管理员看到的：所有借阅统计、图书库存管理教师看到的：推荐书目、专业书籍分类</code></pre><ul><li><p>外模式/模式映射：<br>定义外模式与模式之间的对应关系，每一个外模式都对应一个外模式／模式映象。<br>当模式改变时， DBA修改有关的外模式／模式映象，使外模式保持不变。（逻辑独立性——<mark style="background: #BBFABBA6;">外部模式不受模式变化影响</mark>）</p></li><li><p>模式/内模式映射：<br>模式／内模式映象定义了数据全局逻辑结构与存储结构之间的对应关系。数据库中模式／内模式映象是唯一的。<br>当数据库的存储结构改变了（例如选用了另一种存储结构），数据库管理员修改模式／内模式映象，使模式保持不变。（物理独立性——<mark style="background: #BBFABBA6;">模式不受内部模式变化的影响</mark>）</p></li></ul><p>两级独立性：逻辑独立性和物理独立性。</p><ul><li>工作过程</li></ul><p><img src="/images/Pasted%20image%2020251015214523.png" alt><br><img src="/images/Pasted%20image%2020251015214533.png" alt></p><h1 id="二、关系数据模型与关系代数"><a href="#二、关系数据模型与关系代数" class="headerlink" title="二、关系数据模型与关系代数"></a>二、关系数据模型与关系代数</h1><ul><li>数据模型</li></ul><p>对现实世界数据特征的抽象和对现实世界的模拟。<br>分类（不同层次）：<br>概念模型：常用E-R图表达，用来描述现实世界的概念化结构，与具体DBMS无关<br>逻辑模型：<br>物理模型：</p>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2025/10/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2025/10/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h1><p>1.程序设计语言的发展：<br><img src="/images/Pasted%20image%2020251013104423.png" alt>翻译汇编语言的程序称为汇编程序（器）<br>翻译高级语言的程序称为编译程序（器）</p><p>2.程序设计语言分类<br>强制式</p><p>mongodb+srv://icebreaker:lvlebin666@cluster0.zfum9.mongodb.net/?retryWrites=true&amp;w=majority&amp;appName=Cluster0</p><p>Contrastive Learning for Sequential Recommendation</p><p>Self-supervised Graph Learning for Recommendation</p><p>Are graph augmentations necessary? simple graph contrastive learning for recommendation</p><p>XSimGCL: Towards Extremely Simple Graph Contrastive Learning for Recommendation</p><p>An MLP-based Algorithm for Efficient Contrastive Graph Recommendations</p><p>Simple Yet Effective Graph Contrastive Learning for Recommendation</p><p>Self-Augmented Recommendation with Hypergraph Contrastive Collaborative Filtering</p><p>Improving Graph Collaborative Filtering with Neighborhood-enriched Contrastive Learning</p><p>Improving Long-Tail Item Recommendation with Graph Augmentation</p><p>SSLRec: A Self-Supervised Learning Framework for Recommendation</p><p>SSDRec: Self-Augmented Sequence Denoising for Sequential Recommendation</p><p>Repeated Padding as Data Augmentation for Sequential Recommendation</p><p>Improving Long-Tail Item Recommendation with Graph Augmentation</p><p>A Generic Behavior-Aware Data Augmentation Framework for Sequential Recommendation</p><p>SCM4SR: Structural Causal Model-based Data Augmentation for Robust Session-based Recommendation</p><p>RecDCL: Dual Contrastive Learning for Recommendation</p><p>Graph Augmentation for Recommendation</p><p>A Directional Diffusion Graph Transformer for Recommendation</p><p>Enhanced Hierarchical Contrastive Learning for Recommendation</p><p>Graph Augmentation Empowered Contrastive Learning for Recommendation</p><p>Unveiling Contrastive Learning’s Capability of Neighborhood</p><p><img src="/images/55b5edf293b20ff9394ac76c9c923951.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常微分方程</title>
      <link href="/2024/10/20/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
      <url>/2024/10/20/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="常微分方程总结"><a href="#常微分方程总结" class="headerlink" title="常微分方程总结"></a>常微分方程总结</h1><h2 id="1-一阶微分方程"><a href="#1-一阶微分方程" class="headerlink" title="1. 一阶微分方程"></a>1. 一阶微分方程</h2><h3 id="1-1-可分离变量方程"><a href="#1-1-可分离变量方程" class="headerlink" title="1.1 可分离变量方程"></a>1.1 可分离变量方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} = n(x)</script><p>分离变量，得到：</p><script type="math/tex; mode=display">\int \frac{dy}{g(y)} = \int f(x) dx + C</script><h3 id="1-2-齐次方程"><a href="#1-2-齐次方程" class="headerlink" title="1.2 齐次方程"></a>1.2 齐次方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} = f\left(\frac{y}{x}\right)</script><p>代换 ( y = vx )，化简为：</p><script type="math/tex; mode=display">\frac{dy}{dx} = \frac{v + x \frac{dv}{dx}}{x}</script><p>例如：</p><script type="math/tex; mode=display">\frac{dy}{dx} = \frac{y^2}{x^2 - y^2}</script><p>通过变量代换：</p><script type="math/tex; mode=display">\frac{du}{dx} = \frac{u^2}{1 - u^2}</script><h3 id="1-3-线性方程"><a href="#1-3-线性方程" class="headerlink" title="1.3 线性方程"></a>1.3 线性方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + p(x) y = a(x)</script><p>通解为：</p><script type="math/tex; mode=display">y = e^{-\int p(x)dx}\left( \int a(x) e^{\int p(x)dx} dx + C \right)</script><h3 id="1-4-全微分方程"><a href="#1-4-全微分方程" class="headerlink" title="1.4 全微分方程"></a>1.4 全微分方程</h3><script type="math/tex; mode=display">M(x, y) dx + N(x, y) dy = 0</script><p>若满足条件：</p><script type="math/tex; mode=display">\frac{\partial M}{\partial y} = \frac{\partial N}{\partial x}</script><p>则方程可解。例如：</p><script type="math/tex; mode=display">(1 - 2 \sin(y + x^3)) dx + (8x y^3 + x^3 y^4) dy = 0</script><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><ol><li><strong>直接法</strong>：通过积分求解。</li><li><strong>积分因子法</strong>：找到积分因子，使方程成为全微分方程。</li><li><strong>变量代换法</strong>：通过变量代换化简方程。</li></ol><h3 id="1-5-伯努利方程"><a href="#1-5-伯努利方程" class="headerlink" title="1.5 伯努利方程"></a>1.5 伯努利方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + p(x)y = a(x)y^n</script><p>代换 ( z = y^{1-n} ) 化为线性方程：</p><script type="math/tex; mode=display">\frac{dz}{dx} + (1-n)p(x)z = (1-n)a(x)</script><hr><h2 id="2-高阶微分方程"><a href="#2-高阶微分方程" class="headerlink" title="2. 高阶微分方程"></a>2. 高阶微分方程</h2><h3 id="2-1-降阶法"><a href="#2-1-降阶法" class="headerlink" title="2.1 降阶法"></a>2.1 降阶法</h3><ol><li>( y’’ = y’ - y )</li><li>( y’’ = f(x, y) )</li><li>( y’’ = f(y’) )，通过变量代换简化为一阶方程。</li><li>( f(x, y, y’) = 0 )，使用隐函数或参数形式解。</li></ol><h3 id="2-2-线性微分方程"><a href="#2-2-线性微分方程" class="headerlink" title="2.2 线性微分方程"></a>2.2 线性微分方程</h3><ol><li>( y’’ = f(x) )</li><li>( y’’ = f(x, y) )</li><li>( y’’ = f(y’) )，通过降阶变为一阶方程。</li></ol><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><script type="math/tex; mode=display">x^2 y'' = L(y - xy' - y^2)</script><hr><h2 id="3-特殊类型的方程"><a href="#3-特殊类型的方程" class="headerlink" title="3. 特殊类型的方程"></a>3. 特殊类型的方程</h2><h3 id="3-1-常系数线性微分方程"><a href="#3-1-常系数线性微分方程" class="headerlink" title="3.1 常系数线性微分方程"></a>3.1 常系数线性微分方程</h3><script type="math/tex; mode=display">y'' + p y' + q y = 0</script><p>特征方程：</p><script type="math/tex; mode=display">r^2 + pr + q = 0</script><p>解为：</p><script type="math/tex; mode=display">y = C_1 e^{r_1 x} + C_2 e^{r_2 x}</script><p>当 ( r_1 = r_2 ) 时，解为：</p><script type="math/tex; mode=display">y = (C_1 + C_2 x) e^{r_1 x}</script><h3 id="3-2-参数变换法"><a href="#3-2-参数变换法" class="headerlink" title="3.2 参数变换法"></a>3.2 参数变换法</h3><p>使用合适的变量或参数变换，简化求解方程。</p><hr><h2 id="4-非齐次方程"><a href="#4-非齐次方程" class="headerlink" title="4. 非齐次方程"></a>4. 非齐次方程</h2><script type="math/tex; mode=display">y'' + p(x) y' + q(x) y = f(x)</script><p>通解为：</p><script type="math/tex; mode=display">y = y_h + y_p</script><p>其中 ( y_h ) 是齐次方程的通解，( y_p ) 是特解。</p><hr><h2 id="5-改进方程的变换方法"><a href="#5-改进方程的变换方法" class="headerlink" title="5. 改进方程的变换方法"></a>5. 改进方程的变换方法</h2><p>方程形式为：</p><script type="math/tex; mode=display">x^2 y'' + p x y' + q y = f(x)</script><p>通过拉普拉斯变换、积分因子法或其他方法化简求解。<br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/7a001a183ff6e5122cabca29a1558d4f.4ckvp3qk6v.webp" alt="1"><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/dfca42f4d520e0ca6555ae7e1c77f1f5.8ojowna5an.webp" alt="2"><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/f391e2970ccfd32625b54b5fe4f97dae.86tn828o52.webp" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> 高数笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小猿口算炸鱼cv</title>
      <link href="/2024/10/16/%E5%B0%8F%E7%8C%BF%E5%8F%A3%E7%AE%97%E7%82%B8%E9%B1%BCcv/"/>
      <url>/2024/10/16/%E5%B0%8F%E7%8C%BF%E5%8F%A3%E7%AE%97%E7%82%B8%E9%B1%BCcv/</url>
      
        <content type="html"><![CDATA[<p>首先获取两个数字的位置，然后使用pyautogui截图，使用pytesseract识别数字，然后根据数字的大小判断是否需要输入s或w、<br>利用代码：(按照指示来)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_area</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请将鼠标移动到可能包含第一个数字的区域的左上角，然后按下回车键。&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    top_left = pyautogui.position()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;左上角坐标：<span class="subst">&#123;top_left&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请将鼠标移动到可能包含第一个数字的区域的右下角，然后按下回车键。&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    bottom_right = pyautogui.position()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;右下角坐标：<span class="subst">&#123;bottom_right&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    width = bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]</span><br><span class="line">    height = bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> top_left[<span class="number">0</span>], top_left[<span class="number">1</span>], width, height</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始确定第一个数字的截图区域。&quot;</span>)</span><br><span class="line">first_area = find_area()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始确定第二个数字的截图区域。&quot;</span>)</span><br><span class="line">second_area = find_area()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个数字截图区域：<span class="subst">&#123;first_area&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二个数字截图区域：<span class="subst">&#123;second_area&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">pytesseract.pytesseract.tesseract_cmd = <span class="string">r&#x27;C:\Program Files\Tesseract-OCR\tesseract.exe&#x27;</span><span class="comment"># 记得改地址！！！</span></span><br><span class="line">region1 = (<span class="number">628</span>, <span class="number">275</span>, <span class="number">58</span>, <span class="number">43</span>)<span class="comment">#左边数字位置</span></span><br><span class="line">region2 =(<span class="number">769</span>, <span class="number">278</span>, <span class="number">61</span>, <span class="number">47</span>)<span class="comment"># w右边数字位置</span></span><br><span class="line">write_region = (<span class="number">546</span>, <span class="number">548</span>, <span class="number">28</span>, <span class="number">91</span>)<span class="comment">#绘制符号位置</span></span><br><span class="line"><span class="comment">#位置自己写代码测</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_larger_less_than</span>():</span><br><span class="line">    <span class="comment"># 键盘输入s</span></span><br><span class="line">    pyautogui.press(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_larger_greater_than</span>():</span><br><span class="line">    <span class="comment"># 键盘输入w</span></span><br><span class="line">    pyautogui.press(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    screenshot1 = pyautogui.screenshot(region=region1)</span><br><span class="line">    screenshot1.save(<span class="string">&#x27;number1.png&#x27;</span>)</span><br><span class="line">    number1_str = pytesseract.image_to_string(<span class="string">&#x27;number1.png&#x27;</span>, config=<span class="string">&#x27;--psm 6 -c tessedit_char_whitelist=0123456789&#x27;</span>)</span><br><span class="line">    filtered_number1 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>.isdigit, number1_str))</span><br><span class="line">    <span class="keyword">if</span> filtered_number1:</span><br><span class="line">        number1 = <span class="built_in">int</span>(filtered_number1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第一个数字：<span class="subst">&#123;number1&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">filter</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        number1 = <span class="literal">None</span></span><br><span class="line">    screenshot2 = pyautogui.screenshot(region=region2)</span><br><span class="line">    screenshot2.save(<span class="string">&#x27;number2.png&#x27;</span>)</span><br><span class="line">    number2_str = pytesseract.image_to_string(<span class="string">&#x27;number2.png&#x27;</span>, config=<span class="string">&#x27;--psm 6 -c tessedit_char_whitelist=0123456789&#x27;</span>)</span><br><span class="line">    filtered_number2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>.isdigit, number2_str))</span><br><span class="line">    <span class="keyword">if</span> filtered_number2:</span><br><span class="line">        number2 = <span class="built_in">int</span>(filtered_number2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第二个数字：<span class="subst">&#123;number2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        number2 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> number1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> number2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;比较数字：<span class="subst">&#123;number1&#125;</span> 和 <span class="subst">&#123;number2&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> number1 &gt; number2:</span><br><span class="line">            draw_larger_greater_than()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大于&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> number1 &lt; number2:</span><br><span class="line">            draw_larger_less_than()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小于&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无法正确识别数字。&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex模板</title>
      <link href="/2024/10/15/latex%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/15/latex%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%!TEX program = xelatex</span></span><br><span class="line"><span class="keyword">\documentclass</span>[12pt,a4paper]&#123;article&#125;<span class="comment">% 文档格式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex,hyperref&#125;<span class="comment">% 输出汉字</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;times&#125;<span class="comment">% 英文使用Times New Roman</span></span><br><span class="line"><span class="keyword">\setmainfont</span>&#123;TeX Gyre Termes&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\fontsize</span>&#123;18pt&#125;&#123;27pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 小四字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\heiti</span><span class="comment">% 黑体 </span></span><br><span class="line">基于深度学习的中国大学生摆烂现状分析&#125;&#125;<span class="comment">% 题目</span></span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\fontsize</span>&#123;12pt&#125;&#123;18pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 小四字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\fangsong</span><span class="comment">% 仿宋</span></span><br><span class="line">摆烂王&#125;<span class="keyword">\thanks</span>&#123;作者为中国躺平第一人,(1923-)&#125;<span class="keyword">\\</span><span class="comment">% 标题栏脚注</span></span><br><span class="line"><span class="keyword">\fontsize</span>&#123;10.5pt&#125;&#123;15.75pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 五号字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\fangsong</span><span class="comment">% 仿宋</span></span><br><span class="line">(中国摆烂研究所,<span class="keyword">\ </span>北京<span class="keyword">\ </span>100000,<span class="keyword">\ </span>email: bailanwang@bailan.cn)&#125;&#125;<span class="comment">% 作者单位，“~”表示空格</span></span><br><span class="line"><span class="keyword">\date</span>&#123;&#125;<span class="comment">% 日期（这里避免生成日期）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath,amsfonts,amssymb&#125;<span class="comment">% 为公式输入创造条件的宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;<span class="comment">% 图片插入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;subfigure&#125;<span class="comment">% 并排子图</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;float&#125;<span class="comment">% 浮动环境，用于调整图片位置</span></span><br><span class="line"><span class="keyword">\usepackage</span>[export]&#123;adjustbox&#125;<span class="comment">% 防止过宽的图片</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;bibentry&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;natbib&#125;<span class="comment">% 以上2个为参考文献宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;abstract&#125;<span class="comment">% 两栏文档，一栏摘要及关键字宏包</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\abstracttextfont</span>&#125;&#123;<span class="keyword">\fangsong</span>&#125;<span class="comment">% 摘要内容字体为仿宋</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\abstractname</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;摘<span class="keyword">\quad</span> 要&#125;&#125;<span class="comment">% 更改摘要二字的样式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;<span class="comment">% 字体颜色宏包</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\red</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;1.00,0.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\blue</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.00,1.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\green</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,1.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkblue</span>&#125;[1]</span><br><span class="line">&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.00,0.50&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkgreen</span>&#125;[1]</span><br><span class="line">&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.37,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkred</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.60,0.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\brown</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.50,0.30,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\purple</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.50,0.00,0.50&#125;&#123;<span class="params">#1</span>&#125;&#125;<span class="comment">% 为使用方便而编辑的新指令</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;url&#125;<span class="comment">% 超链接</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;bm&#125;<span class="comment">% 加粗部分公式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;multirow&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;booktabs&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;epstopdf&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;epsfig&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;longtable&#125;<span class="comment">% 长表格</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;supertabular&#125;<span class="comment">% 跨页表格</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;changepage&#125;<span class="comment">% 换页</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;enumerate&#125;<span class="comment">% 短编号</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;caption&#125;<span class="comment">% 设置标题</span></span><br><span class="line"><span class="keyword">\captionsetup</span>[figure]&#123;name=<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> Figure&#125;<span class="comment">% 设置图片编号头</span></span><br><span class="line"><span class="keyword">\captionsetup</span>[table]&#123;name=<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> Table&#125;<span class="comment">% 设置表格编号头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;indentfirst&#125;<span class="comment">% 中文首行缩进</span></span><br><span class="line"><span class="keyword">\usepackage</span>[left=2.50cm,right=2.50cm,top=2.80cm,bottom=2.50cm]&#123;geometry&#125;<span class="comment">% 页边距设置</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\baselinestretch</span>&#125;&#123;1.5&#125;<span class="comment">% 定义行间距（1.5）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125; <span class="comment">%设置全文页眉、页脚的格式</span></span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125;</span><br><span class="line"><span class="keyword">\hypersetup</span>&#123;colorlinks=true,linkcolor=black&#125;<span class="comment">% 去除引用红框，改变颜色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;<span class="comment">% 以下为正文内容</span></span><br><span class="line"><span class="keyword">\maketitle</span><span class="comment">% 产生标题，没有它无法显示标题</span></span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125;<span class="comment">% 页眉左边设为空</span></span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125;<span class="comment">% 页眉中间设为空</span></span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125;<span class="comment">% 页眉右边设为空</span></span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125;<span class="comment">% 页脚左边设为空</span></span><br><span class="line"><span class="keyword">\cfoot</span>&#123;<span class="keyword">\thepage</span>&#125;<span class="comment">% 页脚中间显示页码</span></span><br><span class="line"><span class="keyword">\rfoot</span>&#123;&#125;<span class="comment">% 页脚右边设为空</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line"><span class="keyword">\fangsong</span> </span><br><span class="line">大本钟下寄快递，上面开摆下面寄；同学们做事一定要三思后行：能不能不做，能不能明天做，能不能交给别人做。 文学大叔卡夫卡曾说，我最大的能耐是躺着不动。任何苦难，都能把我打倒。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;adjustwidth&#125;&#123;1.06cm&#125;&#123;1.06cm&#125;</span><br><span class="line"><span class="keyword">\fontsize</span>&#123;10.5pt&#125;&#123;15.75pt&#125;<span class="keyword">\selectfont</span>&#123;<span class="keyword">\heiti</span>&#123;关键词：&#125;<span class="keyword">\fangsong</span>&#123;深度学习、摆烂预测&#125;&#125;</span><br><span class="line"><span class="keyword">\bigskip</span></span><br><span class="line"><span class="keyword">\end</span>&#123;adjustwidth&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125;<span class="comment">% 居中处理</span></span><br><span class="line">&#123;<span class="keyword">\textbf</span>&#123;Abstract&#125;&#125;<span class="comment">% 英文摘要</span></span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;adjustwidth&#125;&#123;1.06cm&#125;&#123;1.06cm&#125;<span class="comment">% 英文摘要内容</span></span><br><span class="line"><span class="keyword">\hspace</span>&#123;1.5em&#125;Attention！If you input &quot;dif&#123;&#125;ferent&quot;, the computer will output &quot;different&quot;, but if you input &quot;dif<span class="keyword">\&#123;</span><span class="keyword">\&#125;</span>ferent&quot;, the computer will output &quot;dif&#123;&#125;ferent&quot;</span><br><span class="line"><span class="keyword">\end</span>&#123;adjustwidth&#125;</span><br><span class="line">    <span class="comment">%页码格式</span></span><br><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 目录</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125; </span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\setcounter</span>&#123;page&#125;&#123;0&#125;</span><br><span class="line">    <span class="comment">% 设置当前页面格式 empty表示无页码</span></span><br><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\newpage</span><span class="comment">% 从新的一页继续</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第一段</span></span><br><span class="line"><span class="keyword">\section</span>&#123;绪论&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂简介&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;大学生的摆烂现状&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;研究开摆的方法&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;基于调查的方法&#125;</span><br><span class="line"><span class="comment">%插入图片</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]<span class="comment">% 插入一张图片，H表示浮动环境下的here</span></span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;&#123;0.83<span class="keyword">\textwidth</span>&#125;<span class="comment">% 小页面尺寸，可自行调节</span></span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=1.0<span class="comment">% 图片尺寸，可自行调节</span></span><br><span class="line"><span class="keyword">\textwidth</span>]&#123;./image/cnn.png&#125;<span class="comment">% 图片名称（图片需与tex文件在同一文件夹）</span></span><br><span class="line"><span class="keyword">\caption</span>&#123;<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> 连续五年摆烂时长的变化&#125;<span class="comment">% 图例</span></span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line"></span><br><span class="line">目前各大企业和机构均通过调查的方法研究躺平的大学生是如何做到躺平的，但是...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;基于深度学习的方法&#125;</span><br><span class="line">                我们提出一种基于深度学习的研究方法，具体的做法是</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 牛顿的摆烂观</span><br><span class="line"><span class="keyword">\item</span> 爱因斯坦如是说</span><br><span class="line"><span class="keyword">\item</span> 我本人也说过...</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;摸鱼方为人上人&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;摆烂理论的发展&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂的起源&#125;</span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;不行就算了&#125;</span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;路见不平，绕道而行&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂理论的传承与发展&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;对摆烂理论的展望&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂的实际应用&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[1.]<span class="comment">% 列举时编号</span></span><br><span class="line"><span class="keyword">\item</span> 啊对</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(a)]<span class="comment">% 次级序号</span></span><br><span class="line"><span class="keyword">\item</span> 太对辣</span><br><span class="line"><span class="keyword">\item</span> 好对捏</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 啊对对</span><br><span class="line"><span class="comment">%\item 啊对对对\footnote&#123;&#125;% 脚注</span></span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;深度学习在摆烂研究中的应用&#125;</span><br><span class="line">        <span class="keyword">\subsection</span>&#123;基于循环神经网络的摆烂研究&#125;</span><br><span class="line">        假设摆烂的人生是由一个序列组成的，我们利用公开的摆烂数据集进行训练</span><br><span class="line">        <span class="keyword">\subsection</span>&#123;基于图神经网络的摆烂研究&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 加*号不会产生数字标号，且不会在目录中显示</span></span><br><span class="line">    <span class="keyword">\section</span>*&#123;摆烂三阶段&#125;</span><br><span class="line">如果你的室友说他在摆烂，那证明你已经输在起跑线上了。今朝有酒今朝醉，明日愁来明日愁。</span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">\section</span>&#123;摆烂三阶段&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;<span class="comment">% 单个公式</span></span><br><span class="line">a=0</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;<span class="comment">% 多个公式</span></span><br><span class="line">A<span class="built_in">_</span>0<span class="built_in">&amp;</span>=<span class="keyword">\frac</span>&#123;V<span class="built_in">_</span>2-V<span class="built_in">_</span>1&#125;&#123;1&#125;<span class="keyword">\\</span></span><br><span class="line">C<span class="built_in">_</span>0<span class="built_in">&amp;</span>=<span class="keyword">\frac</span>&#123;1&#125;&#123;<span class="keyword">\ln</span> <span class="keyword">\dfrac</span>&#123;R<span class="built_in">_</span>&#123;2&#125;<span class="built_in">^</span>&#123;&#x27;&#125;&#125;&#123;R<span class="built_in">_</span>&#123;1&#125;<span class="built_in">^</span>&#123;&#x27;&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;<span class="comment">% 对齐公式</span></span><br><span class="line">A<span class="built_in">_</span>0<span class="built_in">&amp;</span>=3c+6666<span class="keyword">\\</span><span class="comment">% 注意换行</span></span><br><span class="line"><span class="built_in">&amp;</span>=369</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;总结&#125;</span><br><span class="line">    我们通过深度学习方法对摆烂现状的研究，得出一个重要结论，即我工作是为了睡觉。我睡了吃，然后再睡。这里才是真正的生活。</span><br><span class="line">引用了文献 <span class="keyword">\cite</span>&#123;ref1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 参考文献</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\bibitem</span>&#123;ref1&#125;张摆烂,李躺平. “互联网+”背景下摆烂发展对策建议[A]. 中国摆烂科学学术年会论文集[C].中国摆烂研究科学技术协会,2020:4.</span><br><span class="line">        <span class="keyword">\bibitem</span>&#123;ref2&#125;Propht Joseph. 摆王的自我修养[M]. Supercell出版社, 01(2333):-2-<span class="built_in">$</span>-<span class="keyword">\infty</span><span class="built_in">$</span>.</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 用来设置正文文献引用</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;</span><br><span class="line"><span class="keyword">\bibliography</span>&#123;ref&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;<span class="comment">% 结束文档编辑，后面写啥都编译不出来</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来源：<a href="https://blog.csdn.net/weixin_50232758/article/details/131198286?ops_request_misc=%257B%2522request%255Fid%2522%253A%25227DB42474-B73C-4B4C-B16C-005240E89DDA%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=7DB42474-B73C-4B4C-B16C-005240E89DDA&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131198286-null-null.142^v100^pc_search_result_base5&utm_term=latex%E6%A8%A1%E6%9D%BF&spm=1018.2226.3001.4187">来源地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIPS汇编语言写冒泡排序</title>
      <link href="/2024/10/14/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/10/14/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPS汇编语言写冒泡排序"><a href="#MIPS汇编语言写冒泡排序" class="headerlink" title="MIPS汇编语言写冒泡排序"></a>MIPS汇编语言写冒泡排序</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><blockquote><p>环境：MARS MIPS simulator</p></blockquote><p>一些说明：<br>.data:数据域：存储在内存中的特定区域（静态数据区）<br>.text:代码段<br>li:将一个立即数加载到寄存器中的指令。<br>lw:从内存中加载一个字（4字节）到寄存器的指令。<br>la:用于将标签内存地址加载到寄存器中。<br>bge: 表示大于或等于</p><h2 id="C语言源代码：-带flag优化"><a href="#C语言源代码：-带flag优化" class="headerlink" title="C语言源代码：(带flag优化)"></a>C语言源代码：(带flag优化)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MIPS汇编语言代码："><a href="#MIPS汇编语言代码：" class="headerlink" title="MIPS汇编语言代码："></a>MIPS汇编语言代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">.data      # 我先将数据导入</span><br><span class="line">a: .word 1, 3, 6, 4, 2, 5, 9, 8, 7  # 数组,便于加载地址</span><br><span class="line">n: .word 9                 # 数组的长度为9</span><br><span class="line">.text #代码</span><br><span class="line">.globl main # 声明main为全局</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">zero:</span><br><span class="line"> # 清零寄存器</span><br><span class="line">    li $t0, 0         # 清零 $t0</span><br><span class="line">    li $t1, 0         # 清零 $t1</span><br><span class="line">    li $t2, 0         # 清零 $t2</span><br><span class="line">    li $t3, 0         # 清零 $t3</span><br><span class="line">    li $t4, 0         # 清零 $t4</span><br><span class="line">    li $t5, 0         # 清零 $t5</span><br><span class="line">    li $t6, 0         # 清零 $t6</span><br><span class="line">    li $t7, 0         # 清零 $t7</span><br><span class="line">    li $a1, 0         # 清零 flag</span><br><span class="line">    li $a3, 0         # 清零 j</span><br><span class="line">    li $v0, 0         # 清零 i</span><br><span class="line">init:</span><br><span class="line">li $v0 0#i</span><br><span class="line">lw $a0 n#数组长度</span><br><span class="line">subi $a2,$a0,1 #将a0中的值减 1,后续判断,a2为n-1</span><br><span class="line">outer: #外层循环</span><br><span class="line">bge $v0,$a2,print_front# i&lt;n-1-&gt;i&gt;=n-1退出,a0其实已经是n-1</span><br><span class="line">li $a1 0#flag</span><br><span class="line">li $a3 0#j</span><br><span class="line"># beq $a1 $zero #if(flag==0) break;</span><br><span class="line">inner:</span><br><span class="line">sub $t0,$a2,$v0# t0=n-1-i</span><br><span class="line">bge $a3,$t0,endinner# j&lt;n-1-i-&gt;j&gt;=n-1-i</span><br><span class="line">#比较a[j]是否&gt;a[j+1]</span><br><span class="line">sll $t1,$a3,2 #t1=j*4(因为每个数组元素4字节）</span><br><span class="line">la $t2,a# t6记录数组a的首地址</span><br><span class="line">add $t2,$t2,$t1# a的首地址(t2)加上偏移为数t1(j*4)</span><br><span class="line">lw $t3,0($t2)#取出t3=a[j]</span><br><span class="line">lw $t4,4($t2)# 取出t4=a[j+1]</span><br><span class="line">bge $t3,$t4,swap# if(a[j]&gt;a[j+1])，比较</span><br><span class="line">addi $a3,$a3,1</span><br><span class="line">j inner</span><br><span class="line">swap:                 </span><br><span class="line">    sw $t4, 0($t2)    # a[j]=a[j + 1]</span><br><span class="line">    sw $t3, 4($t2)    # a[j + 1] = t3 (原来的 a[j])</span><br><span class="line">    li $a1, 1         # flag = 1</span><br><span class="line">    addi $a3, $a3, 1  # j++</span><br><span class="line">    j inner</span><br><span class="line"></span><br><span class="line">endinner:#主要是为了flag的判断</span><br><span class="line">beq $a1,$zero,print_front</span><br><span class="line">addi $v0,$v0,1#i++</span><br><span class="line">j outer</span><br><span class="line"></span><br><span class="line">print_front:</span><br><span class="line">li $s0,0#i</span><br><span class="line">lw $s1,n# n</span><br><span class="line">print:</span><br><span class="line">bge $s0, $s1, end # 如果 i &gt;= n，跳转到 end</span><br><span class="line">    sll $t1, $s0, 2   # t1 = i * 4</span><br><span class="line">    la $t2, a         # t2 = a的首地址</span><br><span class="line">    add $t2, $t2, $t1 # t2 = a的地址 + t1</span><br><span class="line">    lw $a0, 0($t2)    # 加载 a[i] 到 $a0(打印区域）</span><br><span class="line"></span><br><span class="line">    # 打印 a[i]</span><br><span class="line">    li $v0, 1         # 系统调用 1 = 打印整数</span><br><span class="line">    syscall            # 执行系统调用</span><br><span class="line"></span><br><span class="line">    # 打印空格以便分隔数组元素</span><br><span class="line">    li $v0, 11        # 系统调用 11 = 打印字符</span><br><span class="line">    li $a0, 32        # ASCII 32 是空格</span><br><span class="line">    syscall            # 执行系统调用</span><br><span class="line"></span><br><span class="line">    addi $s0, $s0, 1  # i++</span><br><span class="line">    j print      # 继续打印下一个元素</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">li $v0, 10 </span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h2><p><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/MIPSzhanshi.wijo774ih.webp" alt></p><p>运行示例：<br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/shili1.4qrb75p2fv.webp" alt></p>]]></content>
      
      
      <categories>
          
          <category> 杂谈 </category>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>46级答题卡文件</title>
      <link href="/2024/10/08/46%E7%BA%A7%E7%AD%94%E9%A2%98%E5%8D%A1%E6%96%87%E4%BB%B6/"/>
      <url>/2024/10/08/46%E7%BA%A7%E7%AD%94%E9%A2%98%E5%8D%A1%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>4级答题卡下载：</p></blockquote><p>4级: <a href="/document/CET4.pdf">CET4</a></p><blockquote><p>6级答题卡下载：</p></blockquote><p>6级: <a href="/document/CET6.pdf">CET6</a></p>]]></content>
      
      
      <categories>
          
          <category> 资源 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>起始篇</title>
      <link href="/2024/10/07/start/"/>
      <url>/2024/10/07/start/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>  今天（2024.10.7）是我20岁生日，我把这个网站搭建起来，作为我的生日礼物。我也是2字开头的人了，未来的日子，将会是我一生的黄金时代，我希望自己能够，每天充满激情的活着，永远年轻，永远热情地对待任何人和任何事情，永远无畏，永远保持独立思考，永远的做我自己！<br>                        —————— 致我20~30岁的人生</p><blockquote><p>休对故人思故国，且将新火试新茶，诗酒趁年华。</p></blockquote><p><img src="images/10.jpeg" alt="img1"></p>]]></content>
      
      
      <categories>
          
          <category> 散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>定义：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p></blockquote><p><strong>一个有N个点的图，边一定是大于等于N-1条的。图的最小生成树，就是在这些边中选择N-1条出来，连接所有的N个点。这N-1条边的边权之和是所有方案中最小的。</strong></p><p>通俗的来讲：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。</p><p>如果要求一个图的最小生成树，可以用prim和kruskal算法</p><h2 id="1-prim"><a href="#1-prim" class="headerlink" title="1.prim"></a>1.prim</h2><p>类似于dijkstra算法</p><blockquote><p>int dist[n],state[n],pre[n];<br>dist[1] = 0;<br>for(i : 1 ~ n)<br>{<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = 1;<br>    更新 dist 和 pre;<br>}</p></blockquote><p>参考之前的代码，我们不难得到：（带注释）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">const int N=510,INF=0x3f3f3f3f;</span><br><span class="line">int g[N][N];</span><br><span class="line">int n,m;</span><br><span class="line">int dis[N];</span><br><span class="line">bool st[N];</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int prim()&#123;</span><br><span class="line">    memset(dis,0x3f,sizeof dis);</span><br><span class="line">    dis[1]=0;</span><br><span class="line">    int  res=0;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        int t=-1;</span><br><span class="line">        for(int j=1;j&lt;=n;j++) &#123;</span><br><span class="line">            if (!st[j]&amp;&amp;(t == -1 || dis[t] &gt; dis[j]))&#123;</span><br><span class="line">//j不在集合中，找到最小dis</span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i!=1&amp;&amp;dis[t]==INF) return INF;</span><br><span class="line">//i不是第一个点，如果最短的dis为INF，说明不联通，没有最短路，直接返回</span><br><span class="line">        res+=dis[t];//累积求和</span><br><span class="line">        st[t]=1;</span><br><span class="line"></span><br><span class="line">        for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=min(dis[j],g[t][j]);</span><br><span class="line">//与dijkstra不同，这里不需要dis[t]+g[t][j]应为我们是累加，而不是求每一个点到第一点的最短距离。    </span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    memset(g,0x3f,sizeof g);</span><br><span class="line">    while(m--)&#123;</span><br><span class="line"></span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=min(g[a][b],c);//注意是无向边</span><br><span class="line">    &#125;</span><br><span class="line">    int t=prim();</span><br><span class="line">    if(t==INF) puts(&quot;impossible&quot;);</span><br><span class="line">    else cout&lt;&lt;t;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了之前的经验，我们直到，这里也可以用堆优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL ,LL &gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">LL n,m,resmax;</span><br><span class="line">LL e[N],ne[N],w[N],idx=<span class="number">0</span>,h[N];</span><br><span class="line">LL res[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,LL ww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=ww,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> res);</span><br><span class="line">    res[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t.second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.second]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t.second];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=e[i];</span><br><span class="line">            <span class="keyword">if</span>(res[k]&gt;w[i]&amp;&amp;!st[k])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k]=w[i];<span class="comment">//这一块不太一样</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;res[k],k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a,b,ww;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;ww;</span><br><span class="line">        <span class="built_in">add</span>(a,b,ww);</span><br><span class="line">        <span class="built_in">add</span>(b,a,ww);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        resmax=resmax+res[i];</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;resmax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-kruskal"><a href="#2-kruskal" class="headerlink" title="2.kruskal"></a>2.kruskal</h2><p>思路非常简单，算法实现类似于之前的并查集。</p><blockquote><p><strong>算法思路：</strong></p><p>将所有边按照权值的大小进行升序排序，然后从小到大一一判断。</p><p>如果这个边与之前选择的所有边不会组成回路，就选择这条边分；反之，舍去。</p><p>直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。</p><p>筛选出来的边和所有的顶点构成此连通网的最小生成树。</p><p><strong>判断是否会产生回路的方法为：使用并查集。</strong></p><p>在初始状态下给各个个顶点在不同的集合中。</p><p>遍历过程的每条边，判断这两个顶点的是否在一个集合中。</p><p>如果边上的这两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则要这条边。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="comment">//重载运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge&amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w;</span><br><span class="line">        <span class="type">int</span> ra=<span class="built_in">find</span>(a),rb=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(ra!=rb)&#123;</span><br><span class="line">            p[ra]=rb;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果重载运算符不理解可以换成：</p><p>bool cmp(struct Edge A, struct Edge B)<br>{<br>return A.w &lt; B.w;<br>}<br>然后sort里加个参数 ： sort(edges, edges + m,cmp);</p>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题合集</title>
      <link href="/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="不存在负权边："><a href="#不存在负权边：" class="headerlink" title="不存在负权边："></a>不存在负权边：</h2><h2 id="1-朴素dijkstra算法"><a href="#1-朴素dijkstra算法" class="headerlink" title="1.朴素dijkstra算法"></a>1.朴素dijkstra算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d570c81502a29034d2fd6a13d205fa6.png" alt></p><p>思路：（依然是贪心的思想）</p><p>1.初始化距离：dis[1]=0，dis[i]=INF（正无穷）</p><p>2.循环n次：</p><pre><code>    找到当前不在s中的dis最小的点（s表示已经确定最短距离的点（可以开一个st数组表示））    假设找到了t这个点，用这个点更新其他所有点的最短距离：            if dis\[x\]&gt;dis\[t\]+wi（这里wi表示边权）</code></pre><p>实例演示：</p><p>代码如下：</p><p>一些注意细节（用//表示）</p><p>c++版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span>  q[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dis[t]&gt;dis[j]))&#123;</span><br><span class="line"><span class="comment">//这里t==-1，其实代表是第一次进入，更新t的值，而后面才开始比较</span></span><br><span class="line"><span class="comment">//t记录的是当前最小的那个节点</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],dis[t]+q[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        q[x][y]=<span class="built_in">min</span>(q[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里储存方式用邻接矩阵，主要是因为用于稠密图。图中可能存在重边和自环，<strong>但所有边权均为正值</strong>。算法复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E2%29" alt="\mathcal{O}(n^2)"></p><h2 id="2-堆优化的dijkstra"><a href="#2-堆优化的dijkstra" class="headerlink" title="2.堆优化的dijkstra"></a>2.堆优化的dijkstra</h2><blockquote><p>我们思考一下，上述步骤在哪里可以优化：找到当前不在s中的dis最小的点，我们可以用堆进行优化，优化后复杂度为：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mlogn%29" alt="\mathcal{O}(mlogn)">，堆优化，手写堆和优先队列，但是其实在dijkstra中，不需要手写堆，两个复杂度差不多，不如用优先队列方便。并且，此时为稀疏图，用邻接表更好。</p></blockquote><p> 我们用邻接表现在只需要遍历邻接表中头元素连接的，进行更改，每一次取出队列中的最小值即可</p><p>C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;<span class="comment">//注意开两倍大小</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span><span class="comment">//模板，记下来就好了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver=t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;<span class="comment">//判断是否之前更新过了</span></span><br><span class="line">        st[ver]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[ver]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[ver]+w[i];</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;dis[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//邻接表记得初始化头结点</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如果存在负权边："><a href="#如果存在负权边：" class="headerlink" title="如果存在负权边："></a>如果存在负权边：</h2><h2 id="3-bellman-ford"><a href="#3-bellman-ford" class="headerlink" title="3.bellman-ford"></a>3.bellman-ford</h2><p>（有边数限制）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9afe516391ac442fe5133ac5d101280.png" alt></p><p>对于边的存储方式不高。故可以用结构体初始化。</p><p>方式：初始化所有点到源点的距离为∞，把源点到自己的距离设置为0，遍历n次；每次遍历m条边，用每一条边去更新各点到源点的距离。在碰到<strong>限制</strong>了最短路径上边的长度时就只能用bellman_ford了。</p><blockquote><p>for n次<br>for 所有边 a,b,w (松弛操作)<br>dis[b] = min(dis[b],back[a] + w)</p><p>//注意：这里的backup非常重要，为了防止串联：（假设限制只能用1条边）</p><p>如下图：如果出现这样，不用之前的备份，就会出现1-&gt;3最近为2，而不是3，所以要备份一下之前的情况，用之前未更新的情况更新下一个节点。</p></blockquote><p> <img src="https://i-blog.csdnimg.cn/blog_migrate/97fecf6087afc576d5952a54f56131d7.png" alt></p><p>c++： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> backup[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dis,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> e=edge[j];</span><br><span class="line">            dis[e.b]=<span class="built_in">min</span>(dis[e.b],backup[e.a]+e.w);</span><br><span class="line">            <span class="comment">//其实可以利用动态规划</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        edge[i]=&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(dis[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)  <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//可能存在负权边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><p>例题：<a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/?envType=daily-question&amp;envId=2024-10-03" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> INFTY = INT_MAX / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(<span class="type">int</span> maxTime, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=passingFees.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(maxTime + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INFTY));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=maxTime;t++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; edge:edges)&#123;</span><br><span class="line">                <span class="type">int</span> i=edge[<span class="number">0</span>],j=edge[<span class="number">1</span>],time=edge[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(time&lt;=t)&#123;</span><br><span class="line">                f[t][i]=<span class="built_in">min</span>(f[t][i],f[t-time][j]+passingFees[i]);</span><br><span class="line">                f[t][j]=<span class="built_in">min</span>(f[t][j],f[t-time][i]+passingFees[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=INFTY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxTime;i++)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,f[i][n<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==INFTY) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-spfa"><a href="#4-spfa" class="headerlink" title="4.spfa"></a>4.spfa</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91478d6ee11f64a2e7aa53c436ee63f5.png" alt></p><p>对bellman-ford的优化，不一定每条边都会更新（spfa算法的想法基础）。</p><blockquote><p>dis[b] = min(dis[b],back[a] + w)</p><p>观察这个式子，只有back[a]变小了，我的后继dis[b]才会变小</p><p>所以，我可以用一个队列，在一次变化中，只要有节点变小了，那么就肯定会影响后继节点，就放入队列之中。只要队列不空，就一直类似于bfs一样进行。</p></blockquote><p> 时间复杂度：一般<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28m%29" alt="\mathcal{O}(m)">，最坏<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与dijkstra非常相似</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-spfa拓展：判断负环"><a href="#5-spfa拓展：判断负环" class="headerlink" title="5.spfa拓展：判断负环"></a>5.spfa拓展：判断负环</h2><blockquote><p>原理：鸽笼原理+三角不等式</p><p>使用spfa算法解决是否存在负环问题</p><p>求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：</p><p>方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环<br>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环  </p><p>每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：<br>在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。</p><p>1、dist[x] 记录虚拟源点到x的最短距离</p><p>2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] &gt;= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p><p>3、若dist[j] &gt; dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步</p><p>注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</p></blockquote><p>引入一个cnt数组，记录每个点经过的边数 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb162220a58e90d3b6950f147076b39.png" alt></p><p> e.g.</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb14d0090196cca11c44fec962c7109d.png" alt></p><p> 但是，如果从1开始到不了负环地方，那么就会出问题，我们的解决方法是一开始把所有的点都放入队列中：（本质就是以每个点为起点做一遍spfa）</p><blockquote><p>for(int i=1;i&lt;=n;i++){<br>    st[i]=1;<br>    q.push(i);<br>}</p></blockquote><p> 需要再cnt基础上更改的地方：</p><blockquote><p> dis[j]=dis[t]+w[i];<br>                cnt[j]=cnt[t]+1;<br>                if(cnt[j]&gt;=n) return true;</p><p>还有对于cnt数组的初始化，还有把spfa变成布尔函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    st[i]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源汇最短路问题："><a href="#多源汇最短路问题：" class="headerlink" title="多源汇最短路问题："></a>多源汇最短路问题：</h2><h2 id="6-Floyd算法"><a href="#6-Floyd算法" class="headerlink" title="6.Floyd算法"></a>6.Floyd算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad5b1c79035005f56eb9aada883fa579.png" alt></p><blockquote><p>原理：基于动态规划：</p><p>d[k,i,j]表示从第i个点出发到达j，只经过1~k个点的最短距离</p><p>状态转移方程：d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]</p><p>发现：k与k-1刚好可以消去这个维度，用一个数组就可以实现</p><p>d[i,j]=d[i,k]+d[k,j]</p></blockquote><p>算法时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E3%29" alt="\mathcal{O}(n^3)"></p><p>具体：</p><blockquote><p>假设节点序号是从1到n。<br>    假设f[0][i][j]是一个n*n的矩阵，第i行第j列代表从i到j的权值，如果i到j有边，那么其值就为ci,j（边ij的权值）。<br>    如果没有边，那么其值就为无穷大。</p><pre><code>f\[k\]\[i\]\[j\]代表（k的取值范围是从1到n），在考虑了从1到k的节点作为中间经过的节点时，从i到j的最短路径的长度。比如，f\[1\]\[i\]\[j\]就代表了，在考虑了1节点作为中间经过的节点时，从i到j的最短路径的长度。  分析可知，f\[1\]\[i\]\[j\]的值无非就是两种情况，而现在需要分析的路径也无非两种情况，i-&gt;j，i-&gt;1-&gt;j：  【1】f\[0\]\[i\]\[j\]：i-&gt;j这种路径的长度，小于，i-&gt;1-&gt;j这种路径的长度  【2】f\[0\]\[i\]\[1\]+f\[0\]\[1\]\[j\]：i-&gt;1-&gt;j这种路径的长度，小于，i-&gt;j这种路径的长度形式化说明如下：  f\[k\]\[i\]\[j\]可以从两种情况转移而来：  【1】从f\[k−1\]\[i\]\[j\]转移而来，表示i到j的最短路径不经过k这个节点  【2】从f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\]转移而来，表示i到j的最短路径经过k这个节点总结就是：**f\[k\]\[i\]\[j\]=min(f\[k−1\]\[i\]\[j\],f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\])**  从总结上来看，发现f\[k\]只可能与f\[k−1\]有关。</code></pre></blockquote><p>初始化与读入邻接矩阵（存在自环和重边的时候）：</p><blockquote><p>for (int i = 1; i &lt;= n; i ++ )<br>    for (int j = 1; j &lt;= n; j ++ )<br>        if (i == j) d[i][j] = 0;<br>        else d[i][j] = INF;</p><p>while (m — )<br>{<br>    int a, b, c;<br>    scanf(“%d%d%d”, &amp;a, &amp;b, &amp;c);<br>    d[a][b] = min(d[a][b], c);<br>}</p></blockquote><p>c++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h2><p><strong>线段树=分治法+二叉树结构+Lazy—Tag技术。</strong></p><p>线段树样式[1,10]：</p><p><img src="https://i-blog.csdnimg.cn/direct/c4ceccc5138f472fb6869dd7b9eda0ff.jpeg" alt></p><h2 id="线段树常用操作："><a href="#线段树常用操作：" class="headerlink" title="线段树常用操作："></a>线段树常用操作：</h2><blockquote><p>1.pushup（从下往上）</p><p>1.1(hard) pushdown（懒标记，后面写）</p><p>2.build（建立）</p><p>3.modify（修改）</p><p>4.query(查询)</p></blockquote><p>先来看：</p><h3 id="线段树的build"><a href="#线段树的build" class="headerlink" title="线段树的build"></a>线段树的build</h3><p>前提结论：当做二叉树看：对于编号为x的点：</p><p>父节点：向下取整（x/2），左儿子：2x，右儿子：2x+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//u表示当前线段树一段区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;<span class="comment">//意味着到达了叶节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//等于2*u</span></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);<span class="comment">//等于2*u+1</span></span><br><span class="line">    <span class="comment">//一般后面接上pushup(u)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询，修改"><a href="#查询，修改" class="headerlink" title="查询，修改"></a>查询，修改</h3><p>原理：都是依次递归，比较简单，详细见后面例题。</p><p>补充：查询最小值（图1），查询区间和（图2）构造的线段树</p><p>图1</p><p><img src="https://i-blog.csdnimg.cn/direct/062c469ee45f47bfb923c25acfb5431b.jpeg" alt></p><p>图2</p><p><img src="https://i-blog.csdnimg.cn/direct/8a8942e294ba442fae85db5a0ffc3906.jpeg" alt></p><h3 id="线段树要开4倍空间"><a href="#线段树要开4倍空间" class="headerlink" title="线段树要开4倍空间"></a>线段树要开4倍空间</h3><p><a href="https://blog.csdn.net/qq_43803508/article/details/97501894?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172077162316800213020125%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172077162316800213020125&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-97501894-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%9B%9B%E5%80%8D&amp;spm=1018.2226.3001.4187" title="链接1">链接1</a></p><p><a href="https://blog.csdn.net/smoggyxhdz/article/details/78895672" title="链接2">链接2</a></p><h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p><img src="https://i-blog.csdnimg.cn/direct/b3059411c73541dc9f85ff1aa1c6f37b.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">// 区间[l, r]中的最大值</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">// 由子节点的信息，来计算父节点的信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;   <span class="comment">// 树中节点，已经被完全包含在[l, r]中了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;p);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - x + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((LL)last + x) % p);</span><br><span class="line">            n ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查询区间最大连续子段和，单点修改"><a href="#查询区间最大连续子段和，单点修改" class="headerlink" title="查询区间最大连续子段和，单点修改"></a>查询区间最大连续子段和，单点修改</h2><p><img src="https://i-blog.csdnimg.cn/direct/7a6d8bd767594fd3b278263c5ed859dd.png" alt></p><blockquote><p><img src="https://i-blog.csdnimg.cn/direct/6d8d130358184d258fb10dd78c2d3184.png" alt></p></blockquote><p> 如何知道上面的东西，我们推导一下，首先我们要求一个区间内最大连续子段和。</p><p><img src="https://i-blog.csdnimg.cn/direct/ecec48e31d2c48b3b75e7b3bcc543bc8.png" alt></p><p>那么根据上述操作我们发现我们可以求出tmax，但是引入了lmax与rmax，我们再想办法解决这个问题。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3b0f97492304dd6bcd1f32fd8c5a055.png" alt></p><p> 而引入的sum只需要求出区间和就可以。</p><p>则：pushup代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><h3 id="1-Lazy-Tag方法，区间修改"><a href="#1-Lazy-Tag方法，区间修改" class="headerlink" title="1.Lazy-Tag方法，区间修改"></a>1.Lazy-Tag方法，区间修改</h3><blockquote><p>对于区间修改很容易想到解决办法，还是利用线段树的特征：<br>线段树的节点tree[i]记录了区间i的值,那么可以再定义一个tag[i]，用它统一记录区间i的修改，而不是一个个地修改区间内的每个元素，这个方法称为Lazy-Tag(懒惰标记或延迟标记)。</p></blockquote><p>使用Lazy-Tag方法时，若修改的是一个线段区间，就只对这个线段区间进行整体上的<br>修改，其内部每个元素的内容先不做修改，只有当这个线段区间的一致性被破坏时，才把变<br>化值传递给下一层的子区间。每次区间修改的复杂度为O(log2n),一共m次操作，总复杂<br>度为O(mlog2n)。区间i的Lazy操作，用tag[i]记录。</p><h2 id="2-push-down"><a href="#2-push-down" class="headerlink" title="2.push_down"></a>2.push_down</h2><p>传递函数push_down()是处理Lazy-Tag的一个技巧。在进行多次区间修改时，一个<br>节点需要记录多个区间修改，而这些区间修改往往有冲突。所以，Lazy-Tag的主要操作是解决多<br>次区间修改，用push_down()函数完成。首先检查节点p的tag[p],如果有值，说明前面做<br>区间修改时给p打了tag标记，接下来就把tag[p]传给左右子树，然后把tag[p]清零。</p><p>上述操作图示简述：</p><blockquote><p>Struct Node{</p><p>int l,r;</p><p>int sum,add;</p><p>}</p><p>Add-&gt;懒标记</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/fc0069d2261f41b9b27417c635c181bf.png" alt></p><p> push_down操作：</p><p>对于节点：root，要将root.add把它pushdown一下：</p><blockquote><p>left.add+=root.add</p><p>left.sum+=(left.r-left.l+1)*root.add</p><p>right.add+=root.add</p><p>right.sum+=(right.r-right.l+1)*root.add</p><p>root.add=0</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/f08de53ace964baab724426bec6ef2b0.png" alt></p><p><a href="https://www.luogu.com.cn/problem/P3372" title="【模板】线段树 1 - 洛谷">【模板】线段树 1 - 洛谷</a></p><p>其他同上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (LL)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 一定要分裂</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h2><p><a href="https://www.luogu.com.cn/problem/P5490" title="【模板】扫描线 - 洛谷">【模板】扫描线 - 洛谷</a></p><p> 扫描线：</p><h4 id="面积并"><a href="#面积并" class="headerlink" title="面积并"></a>面积并</h4><p>要求两个矩形叠加后的面积和：</p><p><img src="https://i-blog.csdnimg.cn/direct/a21d40eedece44848fd3ab78c8688c91.png" alt></p><h4 id><a href="#" class="headerlink" title=" "></a> </h4><p>现在假设，扫描线每次会在碰到竖边的时候停下来，如图。</p><p><img src="https://i-blog.csdnimg.cn/direct/251b5590f2184e3d9f00b91a39e43d7b.png" alt></p><h4 id="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"><a href="#为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。" class="headerlink" title="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"></a>为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。</h4><p>然后把所有的横边按照x坐标升序排序。这样，对于每个矩形，扫描线总是会<strong>先碰到左边，然后再碰到右边</strong>。那么就能保证扫描线所截的长度永远非负了。</p><p>这样操作以后，就可以和<strong>线段树</strong>扯上关系。先把所有端点在y轴上离散化（其实就是把所有点的横坐标存到里，然后升序排个序，最后去重）。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3658bbac8cd4dacb96735ec9041874b.png" alt><strong>为什么会想到用线段树，</strong>我们来看一下面积表达式：</p><p><img src="https://latex.csdn.net/eq?%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dx%5B0%5D%5Ccdot%20l_i" alt="\sum_{i=1}^{n}x[0]\cdot l_i"></p><p>我们发现x[0]好求，就是想爱你吨数根节点，关键是<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，也就是<img src="https://latex.csdn.net/eq?%5CDelta%20x_i" alt="\Delta x_i">所对应的矩形另一条边的长度。对于一个矩形，其左边权值为1，右边权值为−1。那么我们发现只要定义一个len表示长度，cnt表示次数，只要cnt激活后，就把len激活到<img src="https://latex.csdn.net/eq?l_i" alt="l_i">。</p><p>e.g.蓝色表示第一次更新，紫色表示第二次更新，绿色表示第三次更新。</p><p>我们发现主要求<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，而每次激活的区域刚好可以用线段树去统计，很方便。（即区间查询）</p><p><img src="https://i-blog.csdnimg.cn/direct/eec576e1283848b29814e77656662f07.png" alt></p><p>（注意离散化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//-1,1</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Seg&amp;t) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];<span class="comment">//区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll len,cnt;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), x) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)&#123;</span><br><span class="line">        tr[u].len=ys[tr[u].r<span class="number">+1</span>]-ys[tr[u].l];<span class="comment">//离散化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].cnt+=d;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>,l,r,d);<span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r,d);<span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//cnt</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">        seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y1);</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line">    ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(seg,seg+j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].tag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒标记迭代"><a href="#懒标记迭代" class="headerlink" title="懒标记迭代"></a>懒标记迭代</h2><p><a href="https://www.luogu.com.cn/problem/P3373" title="【模板】线段树 2 - 洛谷">【模板】线段树 2 - 洛谷</a></p><p>与之前不同，这里这么定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p> 重点步骤：</p><p>推公式：</p><p> <img src="https://i-blog.csdnimg.cn/direct/a8284f38938e4ba2b8013b05857d67dc.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,p,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,w[r],<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add,<span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="type">int</span> x,y,k;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,<span class="number">0</span>,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,k,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>持续更新</strong></p></blockquote><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h3><p><img src="https://i-blog.csdnimg.cn/direct/7af3aa22023c4a58aafeaf5d32fcb659.png" alt></p><p><img src="https://i-blog.csdnimg.cn/direct/7a67b415f7d94b7abd7504062e12a7f1.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r,c;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">               res[i][j]=<span class="built_in">max</span>(res[i<span class="number">-1</span>][j]+w[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);</span><br><span class="line"></span><br><span class="line">       cout&lt;&lt;res[r][c]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h3><p><img src="https://i-blog.csdnimg.cn/direct/546cb151875743aeaf9aa397c9791d30.png" alt></p><p>注意min的问题一定要考虑边界问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">            </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)  res[i][j]=w[i][j];<span class="comment">//不能直接写res[1][1]=w[1][1],因为for循环里面有res[1][1]=INF;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            res[i][j]=INF;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i<span class="number">-1</span>][j]+w[i][j]);<span class="comment">// 只有不在第一行的时候，才可以从上面过来</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);<span class="comment">// 只有不在第一列的时候，才可以从左面过来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res[r][r]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方格取数（洛谷）"><a href="#方格取数（洛谷）" class="headerlink" title="方格取数（洛谷）"></a>方格取数（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1004" title="[NOIP2000 提高组] 方格取数 - 洛谷">[NOIP2000 提高组] 方格取数 - 洛谷</a></p><p><img src="https://i-blog.csdnimg.cn/direct/c2a0bb9f4af6499c8f30ad928e7b0b16.png" alt></p><p><img src="https://i-blog.csdnimg.cn/direct/f2d1b3bdbe9c46ab8d70d05c6e93dda6.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x,y,r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        w[x][y]=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="keyword">if</span>(j1&gt;=<span class="number">1</span>&amp;&amp;j1&lt;=n&amp;&amp;j2&gt;=<span class="number">1</span>&amp;&amp;j2&lt;=n)&#123;</span><br><span class="line">                    <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n + n][n][n]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="传纸条（洛谷）"><a href="#传纸条（洛谷）" class="headerlink" title="传纸条（洛谷）"></a>传纸条（洛谷）</h3><p> <a href="https://www.luogu.com.cn/problem/P1006" title="[NOIP2008 提高组] 传纸条 - 洛谷">[NOIP2008 提高组] 传纸条 - 洛谷</a></p><p>注意：此题是正方形，所以i1,i2的限制只有1&lt;=i1,i2&lt;=n。下面一道题变成长方形(m*n)的时候，就会有限制：</p><p><img src="https://latex.csdn.net/eq?1%5Cleqslant%20i1%20%5Cleqslant%20n%20%5Cquad%201%5Cleqslant%20k-i1%5Cleqslant%20m%5CRightarrow%20%5Cquad%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%201%5Cleqslant%20i1%20%5Cleqslant%20n%5C%5C%20k-m%5Cleqslant%20i1%20%5Cleqslant%20k-1%20%5Cend%7Bmatrix%7D%5Cright." alt="1\leqslant i1 \leqslant n \quad 1\leqslant k-i1\leqslant m\Rightarrow \quad \left\{\begin{matrix} 1\leqslant i1 \leqslant n\\ k-m\leqslant i1 \leqslant k-1 \end{matrix}\right."></p><p><img src="https://latex.csdn.net/eq?summary%20%5CRightarrow%20max%281%2Ck-m%29%5Cleqslant%20i1%20%5Cleqslant%20min%28n%2Ck-1%29" alt="summary \Rightarrow max(1,k-m)\leqslant i1 \leqslant min(n,k-1)"></p><p>同理，i2范围与i1一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=m+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i1&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i2&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                <span class="type">int</span> &amp;x=f[k][i1][i2];</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]+t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m+n][m][m];<span class="comment">//注意两个路线横坐标都是n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><h3 id="（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）"><a href="#（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）" class="headerlink" title="（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）"></a>（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）</h3><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" title="300.最长递增子序列">300.最长递增子序列</a></p><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><p>状态转移方程：</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><img src="https://i-blog.csdnimg.cn/direct/b26f61b3a65d4e4fb5c88c9b65533cdd.png" alt></p><p><img src="https://i-blog.csdnimg.cn/direct/00230658077d4e9397751278591a94a1.png" alt></p><p> 洛谷题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode674-最长连续递增序列"><a href="#leetcode674-最长连续递增序列" class="headerlink" title="leetcode674. 最长连续递增序列"></a>leetcode674. 最长连续递增序列</h3><p> <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/" title="674. 最长连续递增序列">674. 最长连续递增序列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode718-最长重复子数组"><a href="#leetcode718-最长重复子数组" class="headerlink" title="leetcode718. 最长重复子数组"></a>leetcode718. 最长重复子数组</h3><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" title="最长重复子数组">最长重复子数组</a></p><blockquote><p>定义dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。</p><p>确定递推公式：</p><p>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，<strong>dp[i][j] = dp[i - 1][j - 1] + 1;</strong></p><p><strong>例如：【1,2,3,4】与【9,1,2,3】</strong></p><p><strong>当i=1，j=2时候，相等，由于连续，那么i退一格，j退一格，刚好就是dp【i】【j】的更新。</strong></p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p></blockquote><p>这里代码用：i-1是为了方便，不想初始化，直接把0视为无用位，从1开始推。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (nums<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums<span class="number">1.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums<span class="number">2.</span><span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷"><a href="#（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷" class="headerlink" title="（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷"></a>（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷</h3><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/" title="leetcode最长公共子序列">leetcode最长公共子序列</a></p><blockquote><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</p><p>找子问题，</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/c32ead5d55ba4e2fa63d42d4c8083f8c.png" alt></p><blockquote><p> ++++++++++其实就是x与y的问题，我们已知x,y前面的状态确定：</p><p>If x==y    </p><p>那么就是在原来的基础上（i-1,j-1)</p><p>基础上+1即可</p><p>Else(x!=y) 那么就是说我既然是对x,y的讨论</p><p>那么直接看我不要x，还是不要y那个子串</p><p>更长，那么我就让这个更长的记录到这里</p><p>（我们默认了前面状态已知，只需要考虑</p><p>x,y，为什么不考虑把x，y都舍弃，因为</p><p>已经包含在内了（看dp数组的定义）</p></blockquote><p> 举个例子：</p><p> *（dp[2][4],dp[3][3]在之前已经求过了）</p><p><img src="https://i-blog.csdnimg.cn/direct/dbec674c00114527b46ec6332f547d90.png" alt></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=text<span class="number">1.</span><span class="built_in">size</span>(),n2=text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在洛谷：</p><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p>用刚刚的思路，会卡你：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>],b[<span class="number">5000</span>],f[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i==<span class="number">0</span>)||(j==<span class="number">0</span>)) &#123;</span><br><span class="line">      f[i][j]=<span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">if</span> (a[i]==b[j]) f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i]!=b[j]) f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/6124c9d7d33b4f96873c2583634abc63.png" alt></p><p>用优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],map[<span class="number">100001</span>],f[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);map[a[i]]=i;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);f[i]=<span class="number">0x7fffffff</span>;&#125;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len,mid;</span><br><span class="line"><span class="keyword">if</span>(map[b[i]]&gt;f[len])f[++len]=map[b[i]];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[mid]&gt;map[b[i]])r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid<span class="number">+1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[l]=<span class="built_in">min</span>(map[b[i]],f[l]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/06a5f48006ad40619df8d146e3c88ce4.png" alt></p><h3 id="leetcode1035-不相交的线"><a href="#leetcode1035-不相交的线" class="headerlink" title="leetcode1035. 不相交的线"></a>leetcode1035. 不相交的线</h3><p><a href="https://leetcode.cn/problems/uncrossed-lines/description/" title="1035. 不相交的线">1035. 不相交的线</a></p><p>仔细分析此题，发现与上面那道题一模一样，就是求两个数组的LCS。</p><p>代码一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=nums<span class="number">1.</span><span class="built_in">size</span>(),n2=nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>]==nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode53-最大子数组和"><a href="#leetcode53-最大子数组和" class="headerlink" title="leetcode53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></h3><p> <a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></p><p><strong>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]</strong>。</p><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>遍历所以的dp找到最大的输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode392-判断子序列"><a href="#leetcode392-判断子序列" class="headerlink" title="leetcode392. 判断子序列"></a>leetcode392. 判断子序列</h3><p><a href="https://leetcode.cn/problems/is-subsequence/description/" title="392. 判断子序列">392. 判断子序列</a></p><p>与LCS一模一样，就是判断一下是否等于s的长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=s.<span class="built_in">size</span>(),n2=t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[n1][n2]==n1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有更简洁的写法：</p><p>直接扫描string t，然后相同就++i，如果有i==t.size()，那么就有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == c &amp;&amp; ++i == s.<span class="built_in">length</span>()) &#123; <span class="comment">// 所有字符匹配完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// s 是 t 的子序列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode115-不同的子序列"><a href="#leetcode115-不同的子序列" class="headerlink" title="leetcode115. 不同的子序列"></a>leetcode115. 不同的子序列</h3><p><a href="https://leetcode.cn/problems/distinct-subsequences/description/" title="leetcode115. 不同的子序列">leetcode115. 不同的子序列</a></p><blockquote><p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul></blockquote><p> s[i - 1] 与 t[j - 1]相等</p><p><img src="https://i-blog.csdnimg.cn/direct/5c931c26aa4a43bb83da5b3338b84f0b.png" alt></p><p>s[i - 1] 与 t[j - 1] 不相等：</p><p>dp[i][j] = dp[i - 1][j];</p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode583-两个字符串的删除操作"><a href="#leetcode583-两个字符串的删除操作" class="headerlink" title="leetcode583. 两个字符串的删除操作"></a>leetcode583. 两个字符串的删除操作</h3><p> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/" title="leetcode583. 两个字符串的删除操作">leetcode583. 两个字符串的删除操作</a></p><blockquote><p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><p><strong>递推：</strong></p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li></ul><p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];</p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p><p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p><p>因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p><p>这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i][j-1] + 1。</p><p><strong>dp数组如何初始化：</strong></p><p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p><p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。</p><p>dp[0][j]的话同理</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/19ad34e5089f4f9bbcd6c86435f8d9c2.png" alt></p><p><img src="https://i-blog.csdnimg.cn/direct/7cdce9d8f60b48e79f352db055469971.png" alt> java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word2.length();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>,Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode72-编辑距离"><a href="#（-）leetcode72-编辑距离" class="headerlink" title="（*****）leetcode72. 编辑距离"></a>（*****）leetcode72. 编辑距离</h3><p><a href="https://leetcode.cn/problems/edit-distance/description/" title="leetcode72. 编辑距离">leetcode72. 编辑距离</a></p><blockquote><p><strong>dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - 1] == word2[j - 1])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - 1] != word2[j - 1])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure><p> <code>if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code>dp[i][j]</code> 就应该是 <code>dp[i - 1][j - 1]</code>，即<code>dp[i][j] = dp[i - 1][j - 1];</code></p><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/e0fb61d7ba29424c914ce1448042d83b.png" alt></p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = Math.min(insert, Math.min(delete, replace));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = word1.toCharArray(), c2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> c1.length, n = c2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftUp</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">backup</span> <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = leftUp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(leftUp, Math.min(dp[j], dp[j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                leftUp = backup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h3><p><img src="https://i-blog.csdnimg.cn/direct/62f8aab7d3604a71a391af377de2d4f0.png" alt></p><h3 id="怪盗基德的帽子"><a href="#怪盗基德的帽子" class="headerlink" title="怪盗基德的帽子"></a>怪盗基德的帽子</h3><p><img src="https://i-blog.csdnimg.cn/direct/16510be1060f48de83f2c47b76f25628.png" alt>​</p><p> 本质：做了正反两次的LIS（最长上升子序列），进行比较大小，找出最长递增子序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line">        <span class="comment">//正向</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//反向</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h3><p><img src="https://i-blog.csdnimg.cn/direct/5a91eba5e28042bbad2d940aef4f220c.png" alt>​</p><p>与上题一模一样，上题是单边找最大，这题是把两边加起来－1就可以，本质一样。</p><p><img src="https://i-blog.csdnimg.cn/direct/e7f393c4178d49feb69dfc8ca5012554.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合唱队形（洛谷）"><a href="#合唱队形（洛谷）" class="headerlink" title="合唱队形（洛谷）"></a>合唱队形（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1091" title="[NOIP2004 提高组] 合唱队形 - 洛谷">[NOIP2004 提高组] 合唱队形 - 洛谷</a></p><p> 和登山一模一样，但是记得减一就好，模型就是：求前后的最大上升子序列，减去总共的就是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k=n-res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友好城市（洛谷）"><a href="#友好城市（洛谷）" class="headerlink" title="友好城市（洛谷）"></a>友好城市（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P2782" title="友好城市 - 洛谷">友好城市 - 洛谷</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/838bd7f152f4484ca7737d020a0a96e8.png" alt>​</p><p> <img src="https://latex.csdn.net/eq?if%20%5Cquad%20index_1%3Cindex_2%2C%20val_1%3Cval_2%20%2Cthen%20%5C%3A%20OK" alt="if \quad index_1&lt;index_2, val_1&lt;val_2 ,then \: OK"></p><p>单调上升子序列，只有满足如上要求才可以</p><p>所以如果有一个序列排好序，则它一定是递增的，只要知道另一个对应的序列</p><p>的最长上升子序列，就是它最大的不重叠数量。</p><p>方法与思路：（举个栗子，图示）</p><p><img src="https://i-blog.csdnimg.cn/direct/99554a0536aa4e84ac1aa8f88fab466c.png" alt>​</p><p> 用这样的想法我们能得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(w,w+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[j].second&lt;w[i].second)&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会发现如下的东西：</p><p><img src="https://i-blog.csdnimg.cn/direct/df64d4f3c36f4e01afd5365545fc58e7.png" alt>​</p><p> 超时：</p><p>我刚刚利用动态规划复杂度为<img src="https://latex.csdn.net/eq?O%28N%5E2%29" alt="O(N^2)">，我们需要另外找一种方案去优化：</p><p>法1：</p><p>在我们每处理数列中的一位时，我们都要遍历数组找到值小于当前数中的f值的最大值，再用其加一作为现数字的值。如下，就是我们每一次记录的f【i】的值。</p><p><img src="https://i-blog.csdnimg.cn/direct/13e62770c80244c59383f98891808ed3.png" alt>​</p><p>那么，如果我们维护一个取值集合，储存可能的最优解， 就可以优化算法的时间复杂度。</p><p>将一个数放入取值集合的条件是什么？如果两个数a、b ，当他们的f值相同，且a&lt;b,那么a对于后来的数来说，显然比b优。（运用了优先队列的思想）。例如：图中3,1 用1一定比用3好，因为更小。</p><p>我们用函数图像能更直观理解：</p><p><img src="https://i-blog.csdnimg.cn/direct/e485284933e14bfa9947f69052287ce8.png" alt>​</p><p>所以我们只需要那么我们储存下对每一个f值来说的最小原数字值，在处理完新数字后将新数字与与其f值相同的数字比较大小，若小于则更新，若大于接在e数组后面。</p><p>每次我们都查找第一个比当前数大的位置在哪里，用lower_bound即可（二分法）。</p><p><img src="https://i-blog.csdnimg.cn/direct/df4ab32830814ccdac0a73d19f87fdae.png" alt>​</p><p>用p做记录，记录尾插次数，也就是最长递增子序列，此时优化为了：<img src="https://latex.csdn.net/eq?O%28nlog_n%29" alt="O(nlog_n)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii x,pii y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[p]&lt;w[i].second) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            e[p]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            e[<span class="built_in">lower_bound</span>(e,e+p,w[i].second)-e]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会得到：</p><p><img src="https://i-blog.csdnimg.cn/direct/51132788070b4f73a28a6ae8285f194f.png" alt>​</p><h3 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h3><p> <img src="https://i-blog.csdnimg.cn/direct/046762182ae340589a567ec599ec8043.png" alt>​</p><p>只是在第一个最长上升子序列上面加上了w【i】 ，几乎没有什么变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>],f[<span class="number">1005</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i],f[j] + a[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题分析："><a href="#背包问题分析：" class="headerlink" title="背包问题分析："></a>背包问题分析：</h2><h3 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/b3c245b017944a528eb6ff894c1abc63.png" alt>​</p><p><img src="https://i-blog.csdnimg.cn/direct/cea08c3d986e4813ad836065be610623.png" alt>​</p><p>二维： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 滚动数组一维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h4><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/" title="Leetcode 416. 分割等和子集">Leetcode 416. 分割等和子集</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="number">20001</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) res+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(res%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=res/<span class="number">2</span>;j;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i])&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]=dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[res/<span class="number">2</span>]==res/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-1049-最后一块石头的重量-II"><a href="#Leetcode-1049-最后一块石头的重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头的重量 II"></a>Leetcode 1049. 最后一块石头的重量 II</h4><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/" title="Leetcode 1049. 最后一块石头的重量 II">Leetcode 1049. 最后一块石头的重量 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N=<span class="number">15001</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++) res+=stones[i];</span><br><span class="line">        <span class="type">int</span> r=res/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res-dp[r])-dp[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-494-目标和"><a href="#Leetcode-494-目标和" class="headerlink" title="Leetcode 494. 目标和"></a>Leetcode 494. 目标和</h4><p><a href="https://leetcode.cn/problems/target-sum/description/" title="Leetcode 494. 目标和">Leetcode 494. 目标和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) sum+=nums[i];</span><br><span class="line">        <span class="type">int</span> z=(sum+target);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="built_in">abs</span>(target)||z%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos=z/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(pos + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474.一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></h4><p> <a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="type">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/fb1fc89a9c1f4a9692cb69e20a696513.png" alt>​</p><p>优化：</p><p><img src="https://i-blog.csdnimg.cn/direct/979fc6aaf49044b3bc9739faf198ebf6.png" alt>​ <img src="https://i-blog.csdnimg.cn/direct/27e670c68bec4dadbc1177b9fc157c8c.png" alt>​</p><blockquote><p>总结：</p><p>f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包</p><p>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题</p></blockquote><p> 二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &lt;= j)</span><br><span class="line">                f[i][j] =<span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动数组1维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line"><span class="comment">//这里要正序，你可以理解为：f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">//这里是i的f,而不是i-1的，所以要与01背包不同（i-1）则需要逆序</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：多重背包的遍历顺序</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p>for  i：物品</p><pre><code>  for j:背包大小</code></pre><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>for  j：背包大小</p><pre><code>  for i:物品</code></pre><p>为什么：第一个理解成固定一个物品，再遍历背包看是否能满足，第二个应该是固定一个背包空间，遍历物品看是否能满足。</p><p>例如背包大小为3，·物品有1,2</p><p>如果按照第一种方式：先看1，再加入2，只会有{1,2}这种</p><p>如果按照第一种方式：背包大小为0，背包大小为1，背包大小为2，只就有{1,2}，{2,1}这两种</p><p>所以：第一种求的是组合数，第二种求的是排列数。</p><p>518,377就是上述两种不一样的方法。</p></blockquote><h4 id="Leetcde-518-零钱兑换-II"><a href="#Leetcde-518-零钱兑换-II" class="headerlink" title="Leetcde 518. 零钱兑换 II"></a>Leetcde 518. 零钱兑换 II</h4><p><a href="https://leetcode.cn/problems/coin-change-ii/" title="Leetcde 518. 零钱兑换 II">Leetcde 518. 零钱兑换 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]+=dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-377-组合总数Ⅳ"><a href="#Leetcode-377-组合总数Ⅳ" class="headerlink" title="Leetcode 377.组合总数Ⅳ"></a>Leetcode 377.组合总数Ⅳ</h4><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/" title="Leetcode 377.组合总数Ⅳ">Leetcode 377.组合总数Ⅳ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=nums[i]&amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]])</span><br><span class="line">                    dp[j]+=dp[j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-322-零钱兑换"><a href="#leetcode-322-零钱兑换" class="headerlink" title="leetcode 322.零钱兑换"></a>leetcode 322.零钱兑换</h4><p><a href="https://leetcode.cn/problems/coin-change/submissions/556660704/" title="322.零钱兑换">322.零钱兑换</a></p><p><img src="https://i-blog.csdnimg.cn/direct/8885a71b3d3041d584276ef96193276d.jpeg" alt>​</p><p>主要在于递推公式，但是不同的是初始化要一个特别大的数字，然后dp[0]=0;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INT_INF=<span class="number">1e9</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,INT_INF)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==INT_INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode279-完全平方数"><a href="#leetcode279-完全平方数" class="headerlink" title="leetcode279.完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="leetcode279.完全平方数">leetcode279.完全平方数</a></h4><p> <a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="279.完全平方数">279.完全平方数</a></p><p>我们抽象以下：</p><p><img src="https://latex.csdn.net/eq?x%3Da_1%5E2&plus;a_2%5E2&plus;a_3%5E2&plus;...&plus;a_n%5E2" alt="x=a_1^2+a_2^2+a_3^2+...+a_n^2"></p><p>那么立马就变成完全背包问题：</p><p> 物品就是：从1开始一直到100（数据范围），重量就是<img src="https://latex.csdn.net/eq?i%5E2" alt="i^2">，价值就是i，然后dp[j]表示，表示第j个数需要的最少的数据个数。</p><p>和上面那个题一模一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">pow</span>(i,<span class="number">2</span>);j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-<span class="built_in">pow</span>(i,<span class="number">2</span>)]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode129-单词拆分"><a href="#leetcode129-单词拆分" class="headerlink" title="leetcode129.单词拆分"></a>leetcode129.单词拆分</h4><p><a href="https://leetcode.cn/problems/word-break/description/" title="129.单词拆分">129.单词拆分</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;<span class="comment">//为了find到截取的字符串</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">v</span><span class="params">(s.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;  <span class="comment">//字符从0~i开始遍历，指针为i,背包大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;   <span class="comment">//i-j用来截取，只有当v[j]==1并且存在截取的子串时才可以</span></span><br><span class="line">            string sub=s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">                <span class="keyword">if</span>(v[j]&amp;&amp;wordSet.<span class="built_in">find</span>(sub)!=wordSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    v[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h3><h4 id="多重背包看做01背包"><a href="#多重背包看做01背包" class="headerlink" title="多重背包看做01背包"></a>多重背包看做01背包</h4><p><strong>这个思路就是把多重背包看成是01背包：</strong>  </p><p><img src="https://i-blog.csdnimg.cn/direct/8ac2dfb8d2314c0cbb2cceeb06379f19.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,vv,s[<span class="number">101</span>],v[<span class="number">101</span>],w[<span class="number">101</span>],dp[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; vv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">//遍历是第几个物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)<span class="comment">//遍历第i个物品用了j遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = vv;k &gt;= v[i];k--)</span><br><span class="line"><span class="comment">//逆序，遍历从最大背包体积开始，背包大小为k是，向背包放物品。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[k] = <span class="built_in">max</span>(dp[k],dp[k - v[i]] + w[i]);<span class="comment">//递推公式，体积为k时，不选这个物品，就是继承之前的i-1的dp[k]，选这个物品，就是背包大小减去v[i]，加上w[i]的价值。</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[vv];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包二进制优化"><a href="#多重背包二进制优化" class="headerlink" title="多重背包二进制优化"></a>多重背包二进制优化</h4><p>二进制怎么表示这个10呢  <strong>10 = 1 + 2 + 4 + 3，再</strong>比如7 就可以用 1 + 2 + 4来表示，只需要枚举3次。这就是我们二进制优化的思想。</p><p>比如：第一件物品有v[i]=2（体积）,w[i]=3（价值）,s[i]=12（数量）；可以拆分为：4件如下图所示的物品：（其实本质还是01背包，只不过这时候我们合并了一下，让其装的更快了）</p><p><img src="https://i-blog.csdnimg.cn/direct/5ca14df2e84e46b88575bcc906d1ad2a.png" alt>​</p><p><img src="https://i-blog.csdnimg.cn/direct/6da2d39d2d2e48d5bda15a6e58bf2fee.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2001</span>],n,V,v,w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<span class="comment">//第i个物品，体积，价值，个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s;k &lt;&lt;= <span class="number">1</span>)<span class="comment">// 以 k &lt;&lt;= 1 实际上是将 k 的值乘以 2。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= k*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*v]+k*w);<span class="comment">//把第i件多拆分成几件，再做01背包            &#125;</span></span><br><span class="line">            s -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= s*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-s*v]+s*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h4><p><img src="https://i-blog.csdnimg.cn/direct/20ff0a9e87944a0c8cda69d98114f3f7.png" alt>​</p><p> 本题题解来源：<a href="https://www.acwing.com/solution/content/53507/" title="AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing">AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing</a></p><p>按照完全背包的思路：我们列举如下：</p><p><img src="https://i-blog.csdnimg.cn/direct/750241a6c3644699b8b3aa039e6f9aa6.png" alt>​</p><p>r表示j </p><p><img src="https://i-blog.csdnimg.cn/direct/ac046c2c569f4c49a0aba251274ea457.png" alt>​</p><p>具体图示：</p><p><img src="https://i-blog.csdnimg.cn/direct/d922806b35db4606a7656b4970626cf0.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    时间复杂度的分析，我觉得通过代码很难看出来，</span></span><br><span class="line"><span class="comment">    可以通过它的计算过程以及它计算的大体次数来体会。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比如总体积为V = 10,某个物品对应v=3</span></span><br><span class="line"><span class="comment">    以一个物品为例，我们计算的时候，是把这个物品按照对v取余的结果来分类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    v&#x27; = 0是一类，这一类有 0, 3, 6, 9      (v&#x27;表示当前正在求的体积)</span></span><br><span class="line"><span class="comment">    v&#x27; = 1是一类，这一类有 1, 4, 7, 10</span></span><br><span class="line"><span class="comment">    v&#x27; = 2是一类，这一类有 2, 5, 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    我们通过单调队列优化，只是在每一类中进行优化(滑动窗口求最值)</span></span><br><span class="line"><span class="comment">    对于每个物品，我们都会求一遍v&#x27; = 0 ~ v&#x27; = 10，只是再求的过程中把它们分类了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一共n个物品，我们会对 物品1 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       对 物品2 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       ....</span></span><br><span class="line"><span class="comment">                       对 物品n 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总共实际求了 n * (v&#x27;的最大值)， 即 n*m次</span></span><br><span class="line"><span class="comment">    所以时间复杂度是O(n*m)的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20020</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;s);</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>;c &lt; v;c ++)&#123; <span class="comment">// 遍历余数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = c;j &lt;= m;j += v)&#123; <span class="comment">// 遍历余数为c这一类的 体积</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前层的f[j]  暂时等于 上一层的g[j]  相当于 f[i][j] = f[i-1][j];  也就是s = 0情况</span></span><br><span class="line">                f[j] = g[j]; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里一共有s+1个元素,s=0也算一个，所以这里不是j - s*v + 1</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; j - s*v &gt; q[hh]) hh ++; <span class="comment">// 队列存的是下标，也是体积 </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 队列中最大的(s!=0的其中一个)  和 s=0的进行比较</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt) f[j] = <span class="built_in">max</span>(f[j], g[q[hh]] + (j-q[hh])/v*w); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// q[tt]这个体积下的价值，再加上与j体积相差的体积数的价值，才能与g[j]进行对等比较   </span></span><br><span class="line">                <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; g[q[tt]] + (j - q[tt])/v*w &lt;= g[j]) tt --; </span><br><span class="line"></span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="leetcode089-打家劫舍"><a href="#leetcode089-打家劫舍" class="headerlink" title="leetcode089.打家劫舍"></a>leetcode089.打家劫舍</h3><p><a href="https://leetcode.cn/problems/Gu0c2T/" title="089.打家劫舍">089.打家劫舍</a></p><p>用普通线性dp：</p><p>从0~i家店铺最大收益：dp[i]=max(dp[i-1],dp[i-2]+nums[i]);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态机思路：</p><p>引入两个状态：  </p><p>f(i)————&gt;f(i,0)（未选择最后一个店铺）</p><p>|                                  </p><p>|</p><p>-—————-&gt;f(i,1)（选择最后一个店铺）</p><p><img src="https://i-blog.csdnimg.cn/direct/814b9e0b3c1b439d8fdc22ee6760412c.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/house-robber-ii/description/" title="213.打家劫舍2">213.打家劫舍2</a>（补充线性dp）</p><p>对打家劫舍1进行分类讨论，分为：选第一个，还是选最后一个，其他都是一模一样。分为0~n-2与1~n-1，两个部分，也就是考虑nums[0]，考虑nums[n-1]，这两个数的分类讨论。（因为选了0不能选n-1，选了n-1，不能选0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">robrange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[l]=nums[l],dp[l<span class="number">+1</span>]=<span class="built_in">max</span>(nums[l],nums[l<span class="number">+1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">+2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r];</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robrange</span>(nums,<span class="number">0</span>,n<span class="number">-2</span>),<span class="built_in">robrange</span>(nums,<span class="number">1</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买股票的最佳时机4"><a href="#leetcode买股票的最佳时机4" class="headerlink" title="leetcode买股票的最佳时机4"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="leetcode买股票的最佳时机4">leetcode买股票的最佳时机4</a></h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="买股票的最佳时机4">买股票的最佳时机4</a></p><p><img src="https://i-blog.csdnimg.cn/direct/768d8f15245f4acbab273a9ba996d550.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在这个基础上，我们直接搞定前面的几道股票题：</p><h3 id="leetcode121-买卖股票的最佳时机"><a href="#leetcode121-买卖股票的最佳时机" class="headerlink" title="leetcode121. 买卖股票的最佳时机"></a>leetcode121. 买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" title="121. 买卖股票的最佳时机">121. 买卖股票的最佳时机</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , -prices[i]);//因为限定交易次数为1，只能交易1次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , -prices[i]);<span class="comment">//因为限定交易次数为1，只能交易1次</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode122-买卖股票的最佳时机-2"><a href="#leetcode122-买卖股票的最佳时机-2" class="headerlink" title="leetcode122. 买卖股票的最佳时机 2"></a>leetcode122. 买卖股票的最佳时机 2</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" title="122. 买卖股票的最佳时机 II">122. 买卖股票的最佳时机 II</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i]);//无限交易次数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode123-买卖股票的最佳时机-3"><a href="#leetcode123-买卖股票的最佳时机-3" class="headerlink" title="leetcode123. 买卖股票的最佳时机 3"></a>leetcode123. 买卖股票的最佳时机 3</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" title="123. 买卖股票的最佳时机 III">123. 买卖股票的最佳时机 III</a></p><p>变化：</p><blockquote><p> int k=2;即可，其他均不变</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含冷冻期"><a href="#leetcode买卖股票的最佳时机含冷冻期" class="headerlink" title="leetcode买卖股票的最佳时机含冷冻期"></a>leetcode买卖股票的最佳时机含冷冻期</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" title="买卖股票的最佳时间含冷冻期">买卖股票的最佳时间含冷冻期</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/065ce52db1824441a7093d0aacc51f07.png" alt>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];<span class="comment">//第0天买入</span></span><br><span class="line">        <span class="comment">//dp[0][2]=-1e9;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含手续费"><a href="#leetcode买卖股票的最佳时机含手续费" class="headerlink" title="leetcode买卖股票的最佳时机含手续费"></a>leetcode买卖股票的最佳时机含手续费</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" title="买卖股票的最佳时机含手续费">买卖股票的最佳时机含手续费</a></p><blockquote><p>与股票2完全一样，</p><p>dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]-fee) //卖出股票时完成一次交易，支付手续费<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i])</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="leetcode-打家劫舍3"><a href="#leetcode-打家劫舍3" class="headerlink" title="leetcode 打家劫舍3"></a>leetcode 打家劫舍3</h3><p><a href="https://leetcode.cn/problems/house-robber-iii/description/" title="打家劫舍3">打家劫舍3</a></p><p>dp数组（这里写成PII）的含义：first记录不偷该节点所得到的的最大金钱，second记录偷该节点所得到的的最大金钱。</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        PII r=<span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="type">int</span> result=<span class="built_in">max</span>(r.first,r.second);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">robTree</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            PII l=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            PII r=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="type">int</span> rob_yes=root-&gt;val+l.first+r.first;</span><br><span class="line">            <span class="type">int</span> rob_not=<span class="built_in">max</span>(l.second,l.first)+<span class="built_in">max</span>(r.first,r.second);<span class="comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span></span><br><span class="line">            <span class="keyword">return</span> &#123;rob_not,rob_yes&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树的直径"><a href="#leetcode二叉树的直径" class="headerlink" title="leetcode二叉树的直径"></a>leetcode二叉树的直径</h3><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/" title="二叉树的直径">二叉树的直径</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">find</span>(root-&gt;left)<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root-&gt;right)<span class="number">+1</span>;</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树中的最大路径和"><a href="#leetcode二叉树中的最大路径和" class="headerlink" title="leetcode二叉树中的最大路径和"></a>leetcode二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/" title="二叉树中的最大路径和">二叉树中的最大路径和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> re=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTreeReturnlrAndSum</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;right);</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r+root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l+root-&gt;val,r+root-&gt;val),<span class="number">0</span>);<span class="comment">//由于返回值会有负数，所以我们还需要和0，取一个最大值，因为如果是负数，我们可以选择不要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h3 id="小国王"><a href="#小国王" class="headerlink" title="小国王"></a>小国王</h3><p><a href="https://blog.csdn.net/m0_64226820/article/details/126199603?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224A577738-06E0-411F-B41D-A1C6B261F777%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=4A577738-06E0-411F-B41D-A1C6B261F777&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126199603-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%8A%B6%E5%8E%8Bdp&amp;spm=1018.2226.3001.4187" title="状态压缩DP 图文详解（一）_状压dp-CSDN博客">状态压缩DP 图文详解（一）_状压dp-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  K = <span class="number">110</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line"><span class="type">int</span> cnt[M]; <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];<span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">LL f[N][K][M]; <span class="comment">//状态转移方程，存方案数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="comment">//同一行两个国王不能相邻</span></span><br><span class="line">        <span class="keyword">if</span>((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> state)</span> <span class="comment">//统计该状态下国王，即1的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += state &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//预处理所有合法状态 (对于这两个状态压缩有疑惑的，看看上面的图)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i); <span class="comment">//将合法方案存入state</span></span><br><span class="line">            cnt[i] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预处理所有合法状态的合法转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; state.<span class="built_in">size</span>();i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; state.<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b)) <span class="comment">//a &amp; b 指第i行和i-1行不能在同列有国王， check(a|b) == 1 指i和i -1行不能相互攻击到</span></span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j);  <span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//求方案数时，初始方案需要为1,因为全部空 也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i ++) <span class="comment">//枚举每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j ++) <span class="comment">//国王数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>;a &lt; state.<span class="built_in">size</span>();a ++) <span class="comment">//枚举合法方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> b : head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[a]];  <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= c)</span><br><span class="line">                        f[i][j][state[a]] += f[i - <span class="number">1</span>][j - c][state[b]]; <span class="comment">//f[i][state[a]], 在第i行状态为i时，所有i - 1行的状态数量</span></span><br><span class="line">                    <span class="comment">//因为state[a]和a呈映射关系，所也可以写成</span></span><br><span class="line">                    <span class="comment">//  f[i][j][a] += f[i - 1][j - c][b];</span></span><br><span class="line">                &#125;</span><br><span class="line">        cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//我们假设摆到n + 1行，并且另这一行状态为0,那么即得到我们想要的答案， </span></span><br><span class="line">    <span class="comment">//如果我们用f[n][m][]来获取答案，那么我们就要枚举最后一行的所有状态取最大值，来得到答案。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647. 回文子串"></a>leetcode 647. 回文子串</h3><p><a href="https://baijiahao.baidu.com/s?id=1801374813549433140&amp;wfr=spider&amp;for=pc" title="leetcode 647. 回文子串">leetcode 647. 回文子串</a></p><blockquote><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 </p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul><p><strong>遍历顺序：</strong></p><p><img src="https://i-blog.csdnimg.cn/direct/aaa7bfad9bb1431680974ca2d6404d88.png" alt></p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</strong>。</p></blockquote><p> java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想知道最长的回文串长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">         <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j - i ==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s.length();k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;s.length();l++)&#123;</span><br><span class="line">                    res=Math.max(res,dp[k][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindromic-substrings/solutions/379987/hui-wen-zi-chuan-by-leetcode-solution/" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><p>其他方法|</p><h3 id="leetcode-516-最长回文子序列"><a href="#leetcode-516-最长回文子序列" class="headerlink" title="leetcode 516. 最长回文子序列"></a>leetcode 516. 最长回文子序列</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/" title="leetcode 516. 最长回文子序列">leetcode 516. 最长回文子序列</a></p><blockquote><p><strong>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</strong>。</p><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;</p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p><p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p><p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p><p><img src="https://i-blog.csdnimg.cn/direct/95ec8fff8e5649d6ac0cdfb5b27a9b26.png" alt></p><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
