<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>那些振聋发聩的句子</title>
      <link href="/2025/10/08/%E5%B9%B3%E5%BA%B8%E7%9A%84%E9%BA%BB%E9%86%89%E5%89%82/"/>
      <url>/2025/10/08/%E5%B9%B3%E5%BA%B8%E7%9A%84%E9%BA%BB%E9%86%89%E5%89%82/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>如果你是一名乖孩子，每天从早晨开始好好上课，好好做作业，好好预习、复习，直到熄灯时间好好睡觉，过着这种积极健康，平稳中庸的生活，但是缺乏有效自我支配的生活（如果按照学校的规划，你会发现你可以自由支配的业余时间少得可怜）。那么，这样下去，无异于把自己的青春放在保险箱里让他随着时间而调谢。我们必须牢记这样的法则：</p><blockquote><p><strong>平庸的生活方式是麻醉药</strong>。</p></blockquote><p>他只会束缚你，让你没有作为，甚至没有出息地度过大学的四年。</p><p>我想，这四年，真的是最舒服但是又醉难受的四年，舒服是因为我们可以享受青春，难受是因为，这四年注定是一个蜕变的过程，蜕变必将伴随着痛苦与折磨。</p><blockquote><p>经济学十大原则之二：<strong>某种东西的成本是为了得到它而放弃的东西。</strong></p></blockquote><p>我们一直在做选择，你可以选择去游戏或者学习，权衡的关键，并不在于你得到了什么，而是在于你因为选择这件事情，从而放弃了什么。这应该是理性人权衡事物利弊的标准之一。</p><blockquote><p><strong>未经审视的人生不值得度过。</strong> ————苏格拉底</p></blockquote><p>我们必须一日三省问自己，今天的时间是否过得有价值。这个价值并不是用做了多少事情，完成了多少作业，或者比别人更强来决定，而是你究竟比昨天的自己进步了多少，你是否用那你的时间做了你认为有价值的事情。错误只有在改正之后，才能叫做进步。</p><blockquote><p><strong>事件的结果-&gt;事件的原因，是看透一切事物表象的利器</strong></p></blockquote><p>浮于表面的是原因，我们总是看见自己一次又一次的抱怨自己，为什么又做了这样的事情，一次又一次的埋怨着别人，做了哪些哪些事情，却只是看到了有的部分，而忽略了无的原因。</p><blockquote><p><strong>舍弃个性的话，就和死亡无益了</strong><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/c9814b111e4c3788a16f56243e4dc0d0_720.1zi93jantm.webp" alt=""></p><p><strong>孤独摇滚！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息安全数学基础考试后</title>
      <link href="/2024/12/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/"/>
      <url>/2024/12/12/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E8%80%83%E8%AF%95%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<p>考试前几个小时，手写了几份笔记：</p><div class="gallery-container" data-type="data" data-button="">      <div class="gallery-items">[{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/1f82c3a1bfb24b467cd382a49b875eb7.4g4jqmmzto.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/fc5d963227d4fe27391ee024d2efca6e.6m3yceeswi.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/a5c4ca30f40c7ff328b778d969caba1c.9dd0kh0zcx.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/4e9a79868d1ee1ffda492f7c74dec9be.7ax7wf2h55.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/eadea4e1ad7bac698b82c4f306692b23.32i0mlcaeq.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/efab30ee8bea474754730fa52a3e89aa.7p3nnaaw35.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/a8116810937bc167240ac2c36ab2daf5.5mnuz8cd60.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/3b2333320da480ac39717138755b3091.70ae39nh3e.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/245d64e3d5f3ec876cddc8145250ed34.3nro8w71ep.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/9c8e68d8f7b509cc833119f48779e57e.99temr8ef0.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/4eb86fa31d3a624d86bf8cb841240637.45hpxh8jsl.webp","alt":""},{"url":"https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/4eb86fa31d3a624d86bf8cb841240637.5mnuz8cqss.webp","alt":""}]</div>    </div><p>考试的时候，感觉虽然有很多题拿不准主意，但是总的来说还算不错的。</p><p>我想，对于考试这件事物的发展规律就是：你学了，并且深刻理解和掌握了方法，考试就是去展示能力。<br>很遗憾的是，这学期我做的并不好，我这学期像一个弹簧一样，一到紧急的时候，就开始紧张，玩命的学，<br>但是一到不紧急的时候，就开始放松，一直在摆，我真的每次紧急到想死的时候，都特别痛恨之前摆烂的自己，<br>你之前浪费的一切时间，现在会以一种血的代价偿还给你。</p><p>我现在很累，信安数基考试只是个开始罢了，后面的事情还多着，但是事在人为，做就好了，抱怨和情绪之于事物本身是毫无意义的。<br>为什么累，我昨晚刷b站刷到2点半，而且连续好几天这么晚睡，我今天中午有种猝死的感觉，我痛恨自己，为什么不能早睡早起，看到8点的太阳，而不是昏昏沉沉的一天，emo加上懊恼。我觉得我就像是瘾君子，手机就是新型毒品，需要戒掉。真的，手机，尤其是短视频平台，我认为弊大于利，曾经我在辩论赛支持：熬夜是现代人的药，如今，我相当讨厌这个论调，熬夜就是毒，百害而无一利！！！<br>读书，纸质的书籍带来思考，而人类之于牛马的关键区别就是有思考。应该看书，看世界，而不是沉迷于视频，沉迷于消磨时间的虚度。<br>我也不知道再说什么，反正就是一句话吧：谋事在人，做就好了！有时间再好好写一些文字，争取在计组考完能更新一篇公众号！</p>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>吾日三省吾身</title>
      <link href="/2024/10/20/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/"/>
      <url>/2024/10/20/%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<hr><div class='checkbox cyan checked'><input type="radio" checked="checked"/>            <h1>10.20</h1>            </div><div class="tip success"><p>今天算是相当努力的一天，但仍然存在一些问题需要解决：</p><ul><li>9点半左右在起床，严重拖延。主要是晚上睡得太晚导致的。</li><li>今天效率还是可以，但是还是不太专注，在学习的时候除了非常紧急的事情，尽量不要看手机。</li><li>学的内容太单一。</li><li>MC玩的时间太长，没有节制，控制在最多半小时内。<div class="note info flat"><ul><li>学习不同种类</li><li>MC控制时间</li><li>专注加强</li></ul></div></li></ul><blockquote><p>总结：今天表现不错。继续保持。</p></blockquote></div><p><h2>评分: 4/5</h2></p><p><h2>★★★★☆</h2><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/16e04055fa5528f4ef00b0ca5e40ae30.1e8llqgae2.webp" alt=""></p><h2 id=""><a href="#" class="headerlink" title=""></a><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 28.68%" aria-valuenow="28.68" aria-valuemin="0" aria-valuemax="100"><p>今日学习时长占全天时间比（413/1440）</p></div></div></h2><div class='checkbox cyan checked'><input type="radio" checked="checked"/>            <h1>10.21</h1>            </div><div class="tip ban"><p>今天表现很差，就和曾经失败的那些天一模一样，浑浑噩噩，什么都没做，去水一节毫无作用的课，然后以为自己在学习。人啊，就是这样一点一点走向平庸的深渊的。我真的非常反感自己，一事无成，到现在也没有一个真正能坚持喜爱，并且为之真正付出的爱好。说实话，我根本不知道我想要什么，我真正喜爱什么，我一直跟着社会的潮流走，嫉妒那些比我强的。还非常爱封闭自己，又很爱炫耀，其实实际上我什么都没有，什么都不会，用那些简单的花招，包装自己。从来没有真正的，踏实的努力过，相当自卑，又相当自傲。及其不自信，却总是幻想着自己有多么强，从不现实，每次总是嘴上说的很好，但实际做起来什么都做不好，什么都做不出来。失败，失败，迷茫，迷茫。这就是我迄今为止，全部的人生常态了。但是，种一棵树，最好的时间就是现在，我想了想，如果有些习惯我可以从现在开始坚持，是不是，等我30岁就算是坚持了10年，我非常懊恼，在我人生最宝贵的青春岁月浪费在无意义的事情，这也是导致了现在自命不凡却异常平庸的矛盾个体的显现。我还有机会，我还有时间，请不要放弃，悟已往之不谏，知来者之可追。那么如果真的像改变自己，从现在开始吧！</p><ul><li>最严重的就是熬夜，昨晚看漫画，熬到了2点左右，第二天萎靡不振。（客观原因）</li><li>没有动力，没有计划，习惯了拖延，没有自制力，对外界一点点诱惑就会脱离本心。（深度原因）</li><li>习惯摆烂，非常无助，内心渴望认同，过度关心别人，没有自信（心理原因，根本原因）</li><li>学习时候喜欢先享受，再学习，喜欢拖延，过度在意别人的看法，过度关心别人。（行为原因）<div class="note info flat"><ul><li>晚上手机不能上床，11点半左右准时睡觉，12点前必须睡觉。</li><li>每天早上7点左右起床。（就算仍有困意，也要打起精神来）</li><li>带上手机盒子，每次学习的时候打开专注，然后知道学习完成，才能开始玩（除非紧急情况）</li><li>每天保证自主学习时间4h左右（除非特殊情况）</li><li>每天早上布置计划和任务，并且上传到图床上，每天晚上10点20左右开始整理，反思，总结。</li><li>不要在意别人怎么想，不要在意别人有多强，要在意自己，自己今天是否努力，自己是否学习。</li><li>把书带到教室，中午时间用来看书。（这是我的爱好，培养自己的文化素养，这是我之于别人的闪光点）</li></ul></div></li></ul></div><p><h2>评分: 0/5</h2></p><p><h2>☆☆☆☆☆</h2><br><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 12.5%" aria-valuenow="12.5" aria-valuemin="0" aria-valuemax="100"><p>今日学习时长占全天时间比（180/1440）</p></div></div></p><hr><div class='checkbox yellow'><input type="radio" />            <h1>10.20</h1>            </div><div class="tip sync"><p>今天与去机器人社的朱总不期而遇，我和他没有说什么话，还是老套的那样，我问他我什么去机器人了，他说毕竟大二了，大一每天就是上课，回宿舍打游戏，大二了，也该做些事情了，不然这个大学生涯回忆起来，确实会觉得颓丧。我突然理解，什么叫“士别三日，即更刮目相待”了，我也是啊，一事无成，想要取得一点点成功，失败又失败，我从来不会懊恼，也不会反思，为什么会失败。我认为我每次的失败，都在于没有充分的准备，没有充分的准备后，是因为自己根本没有激情，没有想要把事情认真做好的决心和耐心，确实啊，大二了，也该做些什么了！我已经身处深渊，任何有前途的对我来说都是好的。我想，对于孤独摇滚来说，是不是每一步都在进步，一点点的成功，带来正反馈，于是会更加有激情，我现在是缺乏正反馈，但是这必须熬出来，大学生数学竞赛我必须拿奖，就像是孤独摇滚的表演一样，必须成功！因为我已经无路可退，我身后就是失败与更加失败！我现在无竞赛，无科研，无排名，真的一事无成啊！都源于我每次做事情，什么都不能用心去做，把东西深究，认认真真脚踏实地的做事。<br>今天唯一值得庆幸的是7点20起床了，但是早上因为太过于关心别人，所以最后8点才起床，说实话，早起早睡真的很舒服！</p></div><hr><div class='checkbox cyan checked'><input type="radio" checked="checked"/>            <p><h1>10.21，10.22，10.23，</p>            </div><div class="tip ban"><p>这一段时间我什么都没干，可以这么说，我好像一天都在忙，但一天天都不知道自己在忙什么。究其原因，在于自己没有形成</p></div><p>价值观与世界观：</p>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高数笔记</title>
      <link href="/2024/10/20/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/20/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="常微分方程总结"><a href="#常微分方程总结" class="headerlink" title="常微分方程总结"></a>常微分方程总结</h1><h2 id="1-一阶微分方程"><a href="#1-一阶微分方程" class="headerlink" title="1. 一阶微分方程"></a>1. 一阶微分方程</h2><h3 id="1-1-可分离变量方程"><a href="#1-1-可分离变量方程" class="headerlink" title="1.1 可分离变量方程"></a>1.1 可分离变量方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} = n(x)</script><p>分离变量，得到：</p><script type="math/tex; mode=display">\int \frac{dy}{g(y)} = \int f(x) dx + C</script><h3 id="1-2-齐次方程"><a href="#1-2-齐次方程" class="headerlink" title="1.2 齐次方程"></a>1.2 齐次方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} = f\left(\frac{y}{x}\right)</script><p>代换 ( y = vx )，化简为：</p><script type="math/tex; mode=display">\frac{dy}{dx} = \frac{v + x \frac{dv}{dx}}{x}</script><p>例如：</p><script type="math/tex; mode=display">\frac{dy}{dx} = \frac{y^2}{x^2 - y^2}</script><p>通过变量代换：</p><script type="math/tex; mode=display">\frac{du}{dx} = \frac{u^2}{1 - u^2}</script><h3 id="1-3-线性方程"><a href="#1-3-线性方程" class="headerlink" title="1.3 线性方程"></a>1.3 线性方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + p(x) y = a(x)</script><p>通解为：</p><script type="math/tex; mode=display">y = e^{-\int p(x)dx}\left( \int a(x) e^{\int p(x)dx} dx + C \right)</script><h3 id="1-4-全微分方程"><a href="#1-4-全微分方程" class="headerlink" title="1.4 全微分方程"></a>1.4 全微分方程</h3><script type="math/tex; mode=display">M(x, y) dx + N(x, y) dy = 0</script><p>若满足条件：</p><script type="math/tex; mode=display">\frac{\partial M}{\partial y} = \frac{\partial N}{\partial x}</script><p>则方程可解。例如：</p><script type="math/tex; mode=display">(1 - 2 \sin(y + x^3)) dx + (8x y^3 + x^3 y^4) dy = 0</script><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><ol><li><strong>直接法</strong>：通过积分求解。</li><li><strong>积分因子法</strong>：找到积分因子，使方程成为全微分方程。</li><li><strong>变量代换法</strong>：通过变量代换化简方程。</li></ol><h3 id="1-5-伯努利方程"><a href="#1-5-伯努利方程" class="headerlink" title="1.5 伯努利方程"></a>1.5 伯努利方程</h3><script type="math/tex; mode=display">\frac{dy}{dx} + p(x)y = a(x)y^n</script><p>代换 ( z = y^{1-n} ) 化为线性方程：</p><script type="math/tex; mode=display">\frac{dz}{dx} + (1-n)p(x)z = (1-n)a(x)</script><hr><h2 id="2-高阶微分方程"><a href="#2-高阶微分方程" class="headerlink" title="2. 高阶微分方程"></a>2. 高阶微分方程</h2><h3 id="2-1-降阶法"><a href="#2-1-降阶法" class="headerlink" title="2.1 降阶法"></a>2.1 降阶法</h3><ol><li>( y’’ = y’ - y )</li><li>( y’’ = f(x, y) )</li><li>( y’’ = f(y’) )，通过变量代换简化为一阶方程。</li><li>( f(x, y, y’) = 0 )，使用隐函数或参数形式解。</li></ol><h3 id="2-2-线性微分方程"><a href="#2-2-线性微分方程" class="headerlink" title="2.2 线性微分方程"></a>2.2 线性微分方程</h3><ol><li>( y’’ = f(x) )</li><li>( y’’ = f(x, y) )</li><li>( y’’ = f(y’) )，通过降阶变为一阶方程。</li></ol><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><script type="math/tex; mode=display">x^2 y'' = L(y - xy' - y^2)</script><hr><h2 id="3-特殊类型的方程"><a href="#3-特殊类型的方程" class="headerlink" title="3. 特殊类型的方程"></a>3. 特殊类型的方程</h2><h3 id="3-1-常系数线性微分方程"><a href="#3-1-常系数线性微分方程" class="headerlink" title="3.1 常系数线性微分方程"></a>3.1 常系数线性微分方程</h3><script type="math/tex; mode=display">y'' + p y' + q y = 0</script><p>特征方程：</p><script type="math/tex; mode=display">r^2 + pr + q = 0</script><p>解为：</p><script type="math/tex; mode=display">y = C_1 e^{r_1 x} + C_2 e^{r_2 x}</script><p>当 ( r_1 = r_2 ) 时，解为：</p><script type="math/tex; mode=display">y = (C_1 + C_2 x) e^{r_1 x}</script><h3 id="3-2-参数变换法"><a href="#3-2-参数变换法" class="headerlink" title="3.2 参数变换法"></a>3.2 参数变换法</h3><p>使用合适的变量或参数变换，简化求解方程。</p><hr><h2 id="4-非齐次方程"><a href="#4-非齐次方程" class="headerlink" title="4. 非齐次方程"></a>4. 非齐次方程</h2><script type="math/tex; mode=display">y'' + p(x) y' + q(x) y = f(x)</script><p>通解为：</p><script type="math/tex; mode=display">y = y_h + y_p</script><p>其中 ( y_h ) 是齐次方程的通解，( y_p ) 是特解。</p><hr><h2 id="5-改进方程的变换方法"><a href="#5-改进方程的变换方法" class="headerlink" title="5. 改进方程的变换方法"></a>5. 改进方程的变换方法</h2><p>方程形式为：</p><script type="math/tex; mode=display">x^2 y'' + p x y' + q y = f(x)</script><p>通过拉普拉斯变换、积分因子法或其他方法化简求解。<br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/7a001a183ff6e5122cabca29a1558d4f.4ckvp3qk6v.webp" alt="1"><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/dfca42f4d520e0ca6555ae7e1c77f1f5.8ojowna5an.webp" alt="2"><br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/f391e2970ccfd32625b54b5fe4f97dae.86tn828o52.webp" alt="3"></p>]]></content>
      
      
      <categories>
          
          <category> 学习&amp;杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>管理、心理、社会经验与技巧</title>
      <link href="/2024/10/18/%E7%AE%A1%E7%90%86%E3%80%81%E5%BF%83%E7%90%86%E3%80%81%E7%A4%BE%E4%BC%9A%E6%8A%80%E5%B7%A7/"/>
      <url>/2024/10/18/%E7%AE%A1%E7%90%86%E3%80%81%E5%BF%83%E7%90%86%E3%80%81%E7%A4%BE%E4%BC%9A%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="管理："><a href="#管理：" class="headerlink" title="管理："></a>管理：</h1><blockquote><h2 id="SMART原则"><a href="#SMART原则" class="headerlink" title="SMART原则"></a>SMART原则</h2></blockquote><p>Specific:具体的，切中特定的工作指标，不能笼统.<br>Measurable:可衡量的，是量化指标，不是模糊的.<br>Achievable:可实现的，通过努力实现，避免不可能完成的任务.<br>Relevant:相关的，是相关的工作指标，避免无关的.<br>Time-bound:有明确期限的，不能没有时间限制，比如无限期.</p><p>我想就比如我要组个小组完成一个spring项目，我就可以这样制定SMART原则：</p><ul><li>具体性：我们小组要完成一个spring项目，比如开发一个网盘，这个项目要实现用户注册、登录、对文件增删改查等功能。（具体内容）</li><li>可衡量性：，这个功能要实现得尽可能完善，不能有明显的bug，所有功能都能用。（实现预期）</li><li>可达成性：可以完成的，不是不可能的事情。</li><li>相关性：功能是与我们最终目标相关的，不能做一些无用的事情。</li><li>时限性：在一个合理的时间内完成。</li></ul><p><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/image.8s3ar39odz.webp"></p><blockquote><h2 id="管理者常见的问题"><a href="#管理者常见的问题" class="headerlink" title="管理者常见的问题"></a>管理者常见的问题</h2></blockquote><p>1.目标不清晰<br>2.计划缺失或者不可行<br>3.方法或者流程不对或者效率不高<br>4.沟通不充分<br>5.没有及时反馈，调整，纠偏</p><hr><h1 id="心理："><a href="#心理：" class="headerlink" title="心理："></a>心理：</h1><blockquote><h2 id="如果想要让对方接受某个东西，用选择语句"><a href="#如果想要让对方接受某个东西，用选择语句" class="headerlink" title="如果想要让对方接受某个东西，用选择语句"></a>如果想要让对方接受某个东西，用选择语句</h2></blockquote><p>让对方进入你的框架里，比如你去问别人，你喜欢虹夏还是波奇，在那一瞬间他一般会机械的从这两个里面选择一个。</p><p><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/74688b8cfde4a04696ab48628cce9d60.syxw0iajm.webp" width="200" height="300" alt="描述"></p><hr><h1 id="社会："><a href="#社会：" class="headerlink" title="社会："></a>社会：</h1><blockquote><h2 id="人都是自私的"><a href="#人都是自私的" class="headerlink" title="人都是自私的"></a>人都是自私的</h2></blockquote><p>a</p><blockquote><h2 id="低调，要有野心，但是不能让别人看出来"><a href="#低调，要有野心，但是不能让别人看出来" class="headerlink" title="低调，要有野心，但是不能让别人看出来"></a>低调，要有野心，但是不能让别人看出来</h2></blockquote><p>b</p><blockquote><h2 id="一定要有所成就"><a href="#一定要有所成就" class="headerlink" title="一定要有所成就"></a>一定要有所成就</h2></blockquote><p>c</p><blockquote><h2 id="多和能力强的人交流，多看多学多总结"><a href="#多和能力强的人交流，多看多学多总结" class="headerlink" title="多和能力强的人交流，多看多学多总结"></a>多和能力强的人交流，多看多学多总结</h2></blockquote><p>d</p><blockquote><h2 id="社会经历就是闭嘴-祸从口出，察言观色！！！"><a href="#社会经历就是闭嘴-祸从口出，察言观色！！！" class="headerlink" title="社会经历就是闭嘴,祸从口出，察言观色！！！"></a>社会经历就是闭嘴,祸从口出，察言观色！！！</h2></blockquote><p>e</p><blockquote><h2 id="自己不懂的事情，不要说"><a href="#自己不懂的事情，不要说" class="headerlink" title="自己不懂的事情，不要说"></a>自己不懂的事情，不要说</h2></blockquote><p>f</p><blockquote><h2 id="和别人出去吃饭，尽量少玩手机，多和人交流"><a href="#和别人出去吃饭，尽量少玩手机，多和人交流" class="headerlink" title="和别人出去吃饭，尽量少玩手机，多和人交流"></a>和别人出去吃饭，尽量少玩手机，多和人交流</h2></blockquote><p>g</p><blockquote><h2 id="不吐槽，不在背后评论他人"><a href="#不吐槽，不在背后评论他人" class="headerlink" title="不吐槽，不在背后评论他人"></a>不吐槽，不在背后评论他人</h2></blockquote><p>h</p><blockquote><h2 id="看穿了别人，不要指出，尽量不让别人出丑"><a href="#看穿了别人，不要指出，尽量不让别人出丑" class="headerlink" title="看穿了别人，不要指出，尽量不让别人出丑"></a>看穿了别人，不要指出，尽量不让别人出丑</h2></blockquote><p>i</p><blockquote><h2 id="去见别人不要空手，带点礼物"><a href="#去见别人不要空手，带点礼物" class="headerlink" title="去见别人不要空手，带点礼物"></a>去见别人不要空手，带点礼物</h2></blockquote><p>j</p><blockquote><h2 id="多夸别人，少说不好听的（除非是真正的知心朋友）"><a href="#多夸别人，少说不好听的（除非是真正的知心朋友）" class="headerlink" title="多夸别人，少说不好听的（除非是真正的知心朋友）"></a>多夸别人，少说不好听的（除非是真正的知心朋友）</h2></blockquote><p>k</p><blockquote><h2 id="不要主动帮别人，吃力不讨好"><a href="#不要主动帮别人，吃力不讨好" class="headerlink" title="不要主动帮别人，吃力不讨好"></a>不要主动帮别人，吃力不讨好</h2></blockquote><p>l</p><blockquote><h2 id="一定要自信。"><a href="#一定要自信。" class="headerlink" title="一定要自信。"></a>一定要自信。</h2></blockquote><p>m</p><blockquote><h2 id="一定要多看书"><a href="#一定要多看书" class="headerlink" title="一定要多看书"></a>一定要多看书</h2></blockquote><p>n</p><blockquote><h2 id="社交的起点是等价交换"><a href="#社交的起点是等价交换" class="headerlink" title="社交的起点是等价交换"></a>社交的起点是等价交换</h2></blockquote><p>o</p><blockquote><h2 id="临渊慕鱼不如退而结网"><a href="#临渊慕鱼不如退而结网" class="headerlink" title="临渊慕鱼不如退而结网"></a>临渊慕鱼不如退而结网</h2></blockquote><p>p</p><blockquote><h2 id="凡事预则立，不预则废"><a href="#凡事预则立，不预则废" class="headerlink" title="凡事预则立，不预则废"></a>凡事预则立，不预则废</h2></blockquote>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex模板</title>
      <link href="/2024/10/16/%E5%B0%8F%E7%8C%BF%E5%8F%A3%E7%AE%97%E7%82%B8%E9%B1%BCcv/"/>
      <url>/2024/10/16/%E5%B0%8F%E7%8C%BF%E5%8F%A3%E7%AE%97%E7%82%B8%E9%B1%BCcv/</url>
      
        <content type="html"><![CDATA[<p>首先获取两个数字的位置，然后使用pyautogui截图，使用pytesseract识别数字，然后根据数字的大小判断是否需要输入s或w、<br>利用代码：(按照指示来)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_area</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请将鼠标移动到可能包含第一个数字的区域的左上角，然后按下回车键。&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    top_left = pyautogui.position()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;左上角坐标：<span class="subst">&#123;top_left&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;请将鼠标移动到可能包含第一个数字的区域的右下角，然后按下回车键。&quot;</span>)</span><br><span class="line">    <span class="built_in">input</span>()</span><br><span class="line">    bottom_right = pyautogui.position()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;右下角坐标：<span class="subst">&#123;bottom_right&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line">    width = bottom_right[<span class="number">0</span>] - top_left[<span class="number">0</span>]</span><br><span class="line">    height = bottom_right[<span class="number">1</span>] - top_left[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> top_left[<span class="number">0</span>], top_left[<span class="number">1</span>], width, height</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始确定第一个数字的截图区域。&quot;</span>)</span><br><span class="line">first_area = find_area()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;开始确定第二个数字的截图区域。&quot;</span>)</span><br><span class="line">second_area = find_area()</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第一个数字截图区域：<span class="subst">&#123;first_area&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;第二个数字截图区域：<span class="subst">&#123;second_area&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">import</span> pyautogui</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">pytesseract.pytesseract.tesseract_cmd = <span class="string">r&#x27;C:\Program Files\Tesseract-OCR\tesseract.exe&#x27;</span><span class="comment"># 记得改地址！！！</span></span><br><span class="line">region1 = (<span class="number">628</span>, <span class="number">275</span>, <span class="number">58</span>, <span class="number">43</span>)<span class="comment">#左边数字位置</span></span><br><span class="line">region2 =(<span class="number">769</span>, <span class="number">278</span>, <span class="number">61</span>, <span class="number">47</span>)<span class="comment"># w右边数字位置</span></span><br><span class="line">write_region = (<span class="number">546</span>, <span class="number">548</span>, <span class="number">28</span>, <span class="number">91</span>)<span class="comment">#绘制符号位置</span></span><br><span class="line"><span class="comment">#位置自己写代码测</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_larger_less_than</span>():</span><br><span class="line">    <span class="comment"># 键盘输入s</span></span><br><span class="line">    pyautogui.press(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_larger_greater_than</span>():</span><br><span class="line">    <span class="comment"># 键盘输入w</span></span><br><span class="line">    pyautogui.press(<span class="string">&#x27;d&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    screenshot1 = pyautogui.screenshot(region=region1)</span><br><span class="line">    screenshot1.save(<span class="string">&#x27;number1.png&#x27;</span>)</span><br><span class="line">    number1_str = pytesseract.image_to_string(<span class="string">&#x27;number1.png&#x27;</span>, config=<span class="string">&#x27;--psm 6 -c tessedit_char_whitelist=0123456789&#x27;</span>)</span><br><span class="line">    filtered_number1 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>.isdigit, number1_str))</span><br><span class="line">    <span class="keyword">if</span> filtered_number1:</span><br><span class="line">        number1 = <span class="built_in">int</span>(filtered_number1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第一个数字：<span class="subst">&#123;number1&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">filter</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        number1 = <span class="literal">None</span></span><br><span class="line">    screenshot2 = pyautogui.screenshot(region=region2)</span><br><span class="line">    screenshot2.save(<span class="string">&#x27;number2.png&#x27;</span>)</span><br><span class="line">    number2_str = pytesseract.image_to_string(<span class="string">&#x27;number2.png&#x27;</span>, config=<span class="string">&#x27;--psm 6 -c tessedit_char_whitelist=0123456789&#x27;</span>)</span><br><span class="line">    filtered_number2 = <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">filter</span>(<span class="built_in">str</span>.isdigit, number2_str))</span><br><span class="line">    <span class="keyword">if</span> filtered_number2:</span><br><span class="line">        number2 = <span class="built_in">int</span>(filtered_number2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;第二个数字：<span class="subst">&#123;number2&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        number2 = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> number1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> number2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;比较数字：<span class="subst">&#123;number1&#125;</span> 和 <span class="subst">&#123;number2&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> number1 &gt; number2:</span><br><span class="line">            draw_larger_greater_than()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;大于&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> number1 &lt; number2:</span><br><span class="line">            draw_larger_less_than()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;小于&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;无法正确识别数字。&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>latex模板</title>
      <link href="/2024/10/15/latex%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/10/15/latex%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%!TEX program = xelatex</span></span><br><span class="line"><span class="keyword">\documentclass</span>[12pt,a4paper]&#123;article&#125;<span class="comment">% 文档格式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;ctex,hyperref&#125;<span class="comment">% 输出汉字</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;times&#125;<span class="comment">% 英文使用Times New Roman</span></span><br><span class="line"><span class="keyword">\setmainfont</span>&#123;TeX Gyre Termes&#125;</span><br><span class="line"><span class="keyword">\title</span>&#123;<span class="keyword">\fontsize</span>&#123;18pt&#125;&#123;27pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 小四字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\heiti</span><span class="comment">% 黑体 </span></span><br><span class="line">基于深度学习的中国大学生摆烂现状分析&#125;&#125;<span class="comment">% 题目</span></span><br><span class="line"><span class="keyword">\author</span>&#123;<span class="keyword">\fontsize</span>&#123;12pt&#125;&#123;18pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 小四字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\fangsong</span><span class="comment">% 仿宋</span></span><br><span class="line">摆烂王&#125;<span class="keyword">\thanks</span>&#123;作者为中国躺平第一人,(1923-)&#125;<span class="keyword">\\</span><span class="comment">% 标题栏脚注</span></span><br><span class="line"><span class="keyword">\fontsize</span>&#123;10.5pt&#125;&#123;15.75pt&#125;<span class="keyword">\selectfont</span><span class="comment">% 五号字号，1.5倍行距</span></span><br><span class="line">&#123;<span class="keyword">\fangsong</span><span class="comment">% 仿宋</span></span><br><span class="line">(中国摆烂研究所,<span class="keyword">\ </span>北京<span class="keyword">\ </span>100000,<span class="keyword">\ </span>email: bailanwang@bailan.cn)&#125;&#125;<span class="comment">% 作者单位，“~”表示空格</span></span><br><span class="line"><span class="keyword">\date</span>&#123;&#125;<span class="comment">% 日期（这里避免生成日期）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath,amsfonts,amssymb&#125;<span class="comment">% 为公式输入创造条件的宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;graphicx&#125;<span class="comment">% 图片插入宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;subfigure&#125;<span class="comment">% 并排子图</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;float&#125;<span class="comment">% 浮动环境，用于调整图片位置</span></span><br><span class="line"><span class="keyword">\usepackage</span>[export]&#123;adjustbox&#125;<span class="comment">% 防止过宽的图片</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;bibentry&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;natbib&#125;<span class="comment">% 以上2个为参考文献宏包</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;abstract&#125;<span class="comment">% 两栏文档，一栏摘要及关键字宏包</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\abstracttextfont</span>&#125;&#123;<span class="keyword">\fangsong</span>&#125;<span class="comment">% 摘要内容字体为仿宋</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\abstractname</span>&#125;&#123;<span class="keyword">\textbf</span>&#123;摘<span class="keyword">\quad</span> 要&#125;&#125;<span class="comment">% 更改摘要二字的样式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xcolor&#125;<span class="comment">% 字体颜色宏包</span></span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\red</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;1.00,0.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\blue</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.00,1.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\green</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,1.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkblue</span>&#125;[1]</span><br><span class="line">&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.00,0.50&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkgreen</span>&#125;[1]</span><br><span class="line">&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.00,0.37,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\darkred</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.60,0.00,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\brown</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.50,0.30,0.00&#125;&#123;<span class="params">#1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">\newcommand</span>&#123;<span class="keyword">\purple</span>&#125;[1]&#123;<span class="keyword">\textcolor</span>[rgb]&#123;0.50,0.00,0.50&#125;&#123;<span class="params">#1</span>&#125;&#125;<span class="comment">% 为使用方便而编辑的新指令</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;url&#125;<span class="comment">% 超链接</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;bm&#125;<span class="comment">% 加粗部分公式</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;multirow&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;booktabs&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;epstopdf&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;epsfig&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;longtable&#125;<span class="comment">% 长表格</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;supertabular&#125;<span class="comment">% 跨页表格</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;algorithmic&#125;</span><br><span class="line"><span class="keyword">\usepackage</span>&#123;changepage&#125;<span class="comment">% 换页</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;enumerate&#125;<span class="comment">% 短编号</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;caption&#125;<span class="comment">% 设置标题</span></span><br><span class="line"><span class="keyword">\captionsetup</span>[figure]&#123;name=<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> Figure&#125;<span class="comment">% 设置图片编号头</span></span><br><span class="line"><span class="keyword">\captionsetup</span>[table]&#123;name=<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> Table&#125;<span class="comment">% 设置表格编号头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;indentfirst&#125;<span class="comment">% 中文首行缩进</span></span><br><span class="line"><span class="keyword">\usepackage</span>[left=2.50cm,right=2.50cm,top=2.80cm,bottom=2.50cm]&#123;geometry&#125;<span class="comment">% 页边距设置</span></span><br><span class="line"><span class="keyword">\renewcommand</span>&#123;<span class="keyword">\baselinestretch</span>&#125;&#123;1.5&#125;<span class="comment">% 定义行间距（1.5）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;fancyhdr&#125; <span class="comment">%设置全文页眉、页脚的格式</span></span><br><span class="line"><span class="keyword">\pagestyle</span>&#123;fancy&#125;</span><br><span class="line"><span class="keyword">\hypersetup</span>&#123;colorlinks=true,linkcolor=black&#125;<span class="comment">% 去除引用红框，改变颜色</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;<span class="comment">% 以下为正文内容</span></span><br><span class="line"><span class="keyword">\maketitle</span><span class="comment">% 产生标题，没有它无法显示标题</span></span><br><span class="line"><span class="keyword">\lhead</span>&#123;&#125;<span class="comment">% 页眉左边设为空</span></span><br><span class="line"><span class="keyword">\chead</span>&#123;&#125;<span class="comment">% 页眉中间设为空</span></span><br><span class="line"><span class="keyword">\rhead</span>&#123;&#125;<span class="comment">% 页眉右边设为空</span></span><br><span class="line"><span class="keyword">\lfoot</span>&#123;&#125;<span class="comment">% 页脚左边设为空</span></span><br><span class="line"><span class="keyword">\cfoot</span>&#123;<span class="keyword">\thepage</span>&#125;<span class="comment">% 页脚中间显示页码</span></span><br><span class="line"><span class="keyword">\rfoot</span>&#123;&#125;<span class="comment">% 页脚右边设为空</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;abstract&#125;</span><br><span class="line"><span class="keyword">\fangsong</span> </span><br><span class="line">大本钟下寄快递，上面开摆下面寄；同学们做事一定要三思后行：能不能不做，能不能明天做，能不能交给别人做。 文学大叔卡夫卡曾说，我最大的能耐是躺着不动。任何苦难，都能把我打倒。</span><br><span class="line"><span class="keyword">\end</span>&#123;abstract&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;adjustwidth&#125;&#123;1.06cm&#125;&#123;1.06cm&#125;</span><br><span class="line"><span class="keyword">\fontsize</span>&#123;10.5pt&#125;&#123;15.75pt&#125;<span class="keyword">\selectfont</span>&#123;<span class="keyword">\heiti</span>&#123;关键词：&#125;<span class="keyword">\fangsong</span>&#123;深度学习、摆烂预测&#125;&#125;</span><br><span class="line"><span class="keyword">\bigskip</span></span><br><span class="line"><span class="keyword">\end</span>&#123;adjustwidth&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125;<span class="comment">% 居中处理</span></span><br><span class="line">&#123;<span class="keyword">\textbf</span>&#123;Abstract&#125;&#125;<span class="comment">% 英文摘要</span></span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;adjustwidth&#125;&#123;1.06cm&#125;&#123;1.06cm&#125;<span class="comment">% 英文摘要内容</span></span><br><span class="line"><span class="keyword">\hspace</span>&#123;1.5em&#125;Attention！If you input &quot;dif&#123;&#125;ferent&quot;, the computer will output &quot;different&quot;, but if you input &quot;dif<span class="keyword">\&#123;</span><span class="keyword">\&#125;</span>ferent&quot;, the computer will output &quot;dif&#123;&#125;ferent&quot;</span><br><span class="line"><span class="keyword">\end</span>&#123;adjustwidth&#125;</span><br><span class="line">    <span class="comment">%页码格式</span></span><br><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 目录</span></span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;center&#125; </span><br><span class="line"><span class="keyword">\tableofcontents</span></span><br><span class="line"><span class="keyword">\end</span>&#123;center&#125;</span><br><span class="line"><span class="keyword">\setcounter</span>&#123;page&#125;&#123;0&#125;</span><br><span class="line">    <span class="comment">% 设置当前页面格式 empty表示无页码</span></span><br><span class="line"><span class="keyword">\thispagestyle</span>&#123;empty&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\newpage</span><span class="comment">% 从新的一页继续</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%第一段</span></span><br><span class="line"><span class="keyword">\section</span>&#123;绪论&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂简介&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;大学生的摆烂现状&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;研究开摆的方法&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;基于调查的方法&#125;</span><br><span class="line"><span class="comment">%插入图片</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]<span class="comment">% 插入一张图片，H表示浮动环境下的here</span></span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;minipage&#125;&#123;0.83<span class="keyword">\textwidth</span>&#125;<span class="comment">% 小页面尺寸，可自行调节</span></span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\includegraphics</span>[width=1.0<span class="comment">% 图片尺寸，可自行调节</span></span><br><span class="line"><span class="keyword">\textwidth</span>]&#123;./image/cnn.png&#125;<span class="comment">% 图片名称（图片需与tex文件在同一文件夹）</span></span><br><span class="line"><span class="keyword">\caption</span>&#123;<span class="keyword">\fontsize</span>&#123;10pt&#125;&#123;15pt&#125;<span class="keyword">\selectfont</span> 连续五年摆烂时长的变化&#125;<span class="comment">% 图例</span></span><br><span class="line"><span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line"></span><br><span class="line">目前各大企业和机构均通过调查的方法研究躺平的大学生是如何做到躺平的，但是...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;基于深度学习的方法&#125;</span><br><span class="line">                我们提出一种基于深度学习的研究方法，具体的做法是</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;itemize&#125;</span><br><span class="line"><span class="keyword">\item</span> 牛顿的摆烂观</span><br><span class="line"><span class="keyword">\item</span> 爱因斯坦如是说</span><br><span class="line"><span class="keyword">\item</span> 我本人也说过...</span><br><span class="line"><span class="keyword">\end</span>&#123;itemize&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\subsection</span>&#123;摸鱼方为人上人&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;摆烂理论的发展&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂的起源&#125;</span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;不行就算了&#125;</span><br><span class="line">            <span class="keyword">\subsubsection</span>&#123;路见不平，绕道而行&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂理论的传承与发展&#125;</span><br><span class="line"><span class="keyword">\subsubsection</span>&#123;对摆烂理论的展望&#125;</span><br><span class="line"><span class="keyword">\subsection</span>&#123;摆烂的实际应用&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[1.]<span class="comment">% 列举时编号</span></span><br><span class="line"><span class="keyword">\item</span> 啊对</span><br><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[(a)]<span class="comment">% 次级序号</span></span><br><span class="line"><span class="keyword">\item</span> 太对辣</span><br><span class="line"><span class="keyword">\item</span> 好对捏</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"><span class="keyword">\item</span> 啊对对</span><br><span class="line"><span class="comment">%\item 啊对对对\footnote&#123;&#125;% 脚注</span></span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;深度学习在摆烂研究中的应用&#125;</span><br><span class="line">        <span class="keyword">\subsection</span>&#123;基于循环神经网络的摆烂研究&#125;</span><br><span class="line">        假设摆烂的人生是由一个序列组成的，我们利用公开的摆烂数据集进行训练</span><br><span class="line">        <span class="keyword">\subsection</span>&#123;基于图神经网络的摆烂研究&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">% 加*号不会产生数字标号，且不会在目录中显示</span></span><br><span class="line">    <span class="keyword">\section</span>*&#123;摆烂三阶段&#125;</span><br><span class="line">如果你的室友说他在摆烂，那证明你已经输在起跑线上了。今朝有酒今朝醉，明日愁来明日愁。</span><br><span class="line"><span class="keyword">\newpage</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">\section</span>&#123;摆烂三阶段&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;<span class="comment">% 单个公式</span></span><br><span class="line">a=0</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line"><span class="keyword">\centering</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;split&#125;<span class="comment">% 多个公式</span></span><br><span class="line">A<span class="built_in">_</span>0<span class="built_in">&amp;</span>=<span class="keyword">\frac</span>&#123;V<span class="built_in">_</span>2-V<span class="built_in">_</span>1&#125;&#123;1&#125;<span class="keyword">\\</span></span><br><span class="line">C<span class="built_in">_</span>0<span class="built_in">&amp;</span>=<span class="keyword">\frac</span>&#123;1&#125;&#123;<span class="keyword">\ln</span> <span class="keyword">\dfrac</span>&#123;R<span class="built_in">_</span>&#123;2&#125;<span class="built_in">^</span>&#123;&#x27;&#125;&#125;&#123;R<span class="built_in">_</span>&#123;1&#125;<span class="built_in">^</span>&#123;&#x27;&#125;&#125;&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;split&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;<span class="comment">% 对齐公式</span></span><br><span class="line">A<span class="built_in">_</span>0<span class="built_in">&amp;</span>=3c+6666<span class="keyword">\\</span><span class="comment">% 注意换行</span></span><br><span class="line"><span class="built_in">&amp;</span>=369</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">\section</span>&#123;总结&#125;</span><br><span class="line">    我们通过深度学习方法对摆烂现状的研究，得出一个重要结论，即我工作是为了睡觉。我睡了吃，然后再睡。这里才是真正的生活。</span><br><span class="line">引用了文献 <span class="keyword">\cite</span>&#123;ref1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 参考文献</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;thebibliography&#125;&#123;99&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">\bibitem</span>&#123;ref1&#125;张摆烂,李躺平. “互联网+”背景下摆烂发展对策建议[A]. 中国摆烂科学学术年会论文集[C].中国摆烂研究科学技术协会,2020:4.</span><br><span class="line">        <span class="keyword">\bibitem</span>&#123;ref2&#125;Propht Joseph. 摆王的自我修养[M]. Supercell出版社, 01(2333):-2-<span class="built_in">$</span>-<span class="keyword">\infty</span><span class="built_in">$</span>.</span><br><span class="line"><span class="keyword">\end</span>&#123;thebibliography&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">% 用来设置正文文献引用</span></span><br><span class="line"><span class="keyword">\bibliographystyle</span>&#123;plain&#125;</span><br><span class="line"><span class="keyword">\bibliography</span>&#123;ref&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;<span class="comment">% 结束文档编辑，后面写啥都编译不出来</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>来源：<a href="https://blog.csdn.net/weixin_50232758/article/details/131198286?ops_request_misc=%257B%2522request%255Fid%2522%253A%25227DB42474-B73C-4B4C-B16C-005240E89DDA%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=7DB42474-B73C-4B4C-B16C-005240E89DDA&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-131198286-null-null.142^v100^pc_search_result_base5&utm_term=latex%E6%A8%A1%E6%9D%BF&spm=1018.2226.3001.4187">来源地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习&amp;杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MIPS汇编语言写冒泡排序</title>
      <link href="/2024/10/14/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/10/14/MIPS%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPS汇编语言写冒泡排序"><a href="#MIPS汇编语言写冒泡排序" class="headerlink" title="MIPS汇编语言写冒泡排序"></a>MIPS汇编语言写冒泡排序</h1><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><blockquote><p>环境：MARS MIPS simulator</p></blockquote><p>一些说明：<br>.data:数据域：存储在内存中的特定区域（静态数据区）<br>.text:代码段<br>li:将一个立即数加载到寄存器中的指令。<br>lw:从内存中加载一个字（4字节）到寄存器的指令。<br>la:用于将标签内存地址加载到寄存器中。<br>bge: 表示大于或等于</p><h2 id="C语言源代码：-带flag优化"><a href="#C语言源代码：-带flag优化" class="headerlink" title="C语言源代码：(带flag优化)"></a>C语言源代码：(带flag优化)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&gt;a[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MIPS汇编语言代码："><a href="#MIPS汇编语言代码：" class="headerlink" title="MIPS汇编语言代码："></a>MIPS汇编语言代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">.data      # 我先将数据导入</span><br><span class="line">a: .word 1, 3, 6, 4, 2, 5, 9, 8, 7  # 数组,便于加载地址</span><br><span class="line">n: .word 9                 # 数组的长度为9</span><br><span class="line">.text #代码</span><br><span class="line">.globl main # 声明main为全局</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">zero:</span><br><span class="line"> # 清零寄存器</span><br><span class="line">    li $t0, 0         # 清零 $t0</span><br><span class="line">    li $t1, 0         # 清零 $t1</span><br><span class="line">    li $t2, 0         # 清零 $t2</span><br><span class="line">    li $t3, 0         # 清零 $t3</span><br><span class="line">    li $t4, 0         # 清零 $t4</span><br><span class="line">    li $t5, 0         # 清零 $t5</span><br><span class="line">    li $t6, 0         # 清零 $t6</span><br><span class="line">    li $t7, 0         # 清零 $t7</span><br><span class="line">    li $a1, 0         # 清零 flag</span><br><span class="line">    li $a3, 0         # 清零 j</span><br><span class="line">    li $v0, 0         # 清零 i</span><br><span class="line">init:</span><br><span class="line">li $v0 0#i</span><br><span class="line">lw $a0 n#数组长度</span><br><span class="line">subi $a2,$a0,1 #将a0中的值减 1,后续判断,a2为n-1</span><br><span class="line">outer: #外层循环</span><br><span class="line">bge $v0,$a2,print_front# i&lt;n-1-&gt;i&gt;=n-1退出,a0其实已经是n-1</span><br><span class="line">li $a1 0#flag</span><br><span class="line">li $a3 0#j</span><br><span class="line"># beq $a1 $zero #if(flag==0) break;</span><br><span class="line">inner:</span><br><span class="line">sub $t0,$a2,$v0# t0=n-1-i</span><br><span class="line">bge $a3,$t0,endinner# j&lt;n-1-i-&gt;j&gt;=n-1-i</span><br><span class="line">#比较a[j]是否&gt;a[j+1]</span><br><span class="line">sll $t1,$a3,2 #t1=j*4(因为每个数组元素4字节）</span><br><span class="line">la $t2,a# t6记录数组a的首地址</span><br><span class="line">add $t2,$t2,$t1# a的首地址(t2)加上偏移为数t1(j*4)</span><br><span class="line">lw $t3,0($t2)#取出t3=a[j]</span><br><span class="line">lw $t4,4($t2)# 取出t4=a[j+1]</span><br><span class="line">bge $t3,$t4,swap# if(a[j]&gt;a[j+1])，比较</span><br><span class="line">addi $a3,$a3,1</span><br><span class="line">j inner</span><br><span class="line">swap:                 </span><br><span class="line">    sw $t4, 0($t2)    # a[j]=a[j + 1]</span><br><span class="line">    sw $t3, 4($t2)    # a[j + 1] = t3 (原来的 a[j])</span><br><span class="line">    li $a1, 1         # flag = 1</span><br><span class="line">    addi $a3, $a3, 1  # j++</span><br><span class="line">    j inner</span><br><span class="line"></span><br><span class="line">endinner:#主要是为了flag的判断</span><br><span class="line">beq $a1,$zero,print_front</span><br><span class="line">addi $v0,$v0,1#i++</span><br><span class="line">j outer</span><br><span class="line"></span><br><span class="line">print_front:</span><br><span class="line">li $s0,0#i</span><br><span class="line">lw $s1,n# n</span><br><span class="line">print:</span><br><span class="line">bge $s0, $s1, end # 如果 i &gt;= n，跳转到 end</span><br><span class="line">    sll $t1, $s0, 2   # t1 = i * 4</span><br><span class="line">    la $t2, a         # t2 = a的首地址</span><br><span class="line">    add $t2, $t2, $t1 # t2 = a的地址 + t1</span><br><span class="line">    lw $a0, 0($t2)    # 加载 a[i] 到 $a0(打印区域）</span><br><span class="line"></span><br><span class="line">    # 打印 a[i]</span><br><span class="line">    li $v0, 1         # 系统调用 1 = 打印整数</span><br><span class="line">    syscall            # 执行系统调用</span><br><span class="line"></span><br><span class="line">    # 打印空格以便分隔数组元素</span><br><span class="line">    li $v0, 11        # 系统调用 11 = 打印字符</span><br><span class="line">    li $a0, 32        # ASCII 32 是空格</span><br><span class="line">    syscall            # 执行系统调用</span><br><span class="line"></span><br><span class="line">    addi $s0, $s0, 1  # i++</span><br><span class="line">    j print      # 继续打印下一个元素</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">li $v0, 10 </span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结果展示："><a href="#结果展示：" class="headerlink" title="结果展示："></a>结果展示：</h2><p><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/MIPSzhanshi.wijo774ih.webp" alt=""></p><p>运行示例：<br><img src="https://github.com/lvlebin2876587146/picx-images-hosting/raw/master/shili1.4qrb75p2fv.webp" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 代码杂谈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题</title>
      <link href="/2024/10/08/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
      <url>/2024/10/08/leetcode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>2024.10.8<br>题目：<br>给你一份旅游线路图，该线路图中的旅行线路用数组 <code>paths</code> 表示，其中 <code>paths[i] = [cityAi, cityBi]</code> 表示该线路将会从 <code>cityAi</code> 直接前往 <code>cityBi</code> 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市<em>。</em></p></blockquote><p>题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>paths = [[“London”,”New York”],[“New York”,”Lima”],[“Lima”,”Sao Paulo”]]<br><strong>输出：</strong>“Sao Paulo”<br><strong>解释：</strong>从 “London” 出发，最后抵达终点站 “Sao Paulo” 。本次旅行的路线是 “London” -&gt; “New York” -&gt; “Lima” -&gt; “Sao Paulo” 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>paths = [[“B”,”C”],[“D”,”B”],[“C”,”A”]]<br><strong>输出：</strong>“A”<br><strong>解释：</strong>所有可能的线路是：<br>“D” -&gt; “B” -&gt; “C” -&gt; “A”.<br>“B” -&gt; “C” -&gt; “A”.<br>“C” -&gt; “A”.<br>“A”.<br>显然，旅行终点站是 “A” 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>paths = [[“A”,”Z”]]<br><strong>输出：</strong>“Z”</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= paths.length &lt;= 100</code></li><li><code>paths[i].length == 2</code></li><li><code>1 &lt;= cityAi.length, cityBi.length &lt;= 10</code></li><li><code>cityAi != cityBi</code></li><li>所有字符串均由大小写英文字母和空格字符组成。</li></ul><div class="note info modern"><p>我的思路：我本来想要建图，然后从任意一个点开始遍历，<br>直到最后没有为止，或者找没有出度的点，但是发现这样太麻烦了，<br>于是想了一个简单的方法，就是将所有起点存入一个集合，<br>然后遍历终点，如果终点不在起点集合中，那么就是终点了。刚好可以用到哈希表。非常巧妙！</p></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//nb</span></span><br><span class="line">    <span class="function">string <span class="title">destCity</span><span class="params">(vector&lt;vector&lt;string&gt;&gt; &amp;paths)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; citiesA;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;path : paths) &#123;</span><br><span class="line">            citiesA.<span class="built_in">insert</span>(path[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;path : paths) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!citiesA.<span class="built_in">count</span>(path[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> path[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>给你一个数组 <code>nums</code> 和一个整数 <code>k</code> 。你需要找到 <code>nums</code> 的一个 </p><p>子数组</p><p> ，满足子数组中所有元素按位或运算 <code>OR</code> 的值与 <code>k</code> 的 <strong>绝对差</strong> 尽可能 <strong>小</strong> 。换言之，你需要选择一个子数组 <code>nums[l..r]</code> 满足 <code>|k - (nums[l] OR nums[l + 1] ... OR nums[r])|</code> 最小。</p><p>请你返回 <strong>最小</strong> 的绝对差值。</p><p><strong>子数组</strong> 是数组中连续的 <strong>非空</strong> 元素序列。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>nums = [1,2,4,5], k = 3</p><p><strong>输出：</strong>0</p><p><strong>解释：</strong></p><p>子数组 <code>nums[0..1]</code> 的按位 <code>OR</code> 运算值为 3 ，得到最小差值 <code>|3 - 3| = 0</code> 。</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>nums = [1,3,1,3], k = 2</p><p><strong>输出：</strong>1</p><p><strong>解释：</strong></p><p>子数组 <code>nums[1..1]</code> 的按位 <code>OR</code> 运算值为 3 ，得到最小差值 <code>|3 - 2| = 1</code> 。</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>nums = [1], k = 10</p><p><strong>输出：</strong>9</p><p><strong>解释：</strong></p><p>只有一个子数组，按位 <code>OR</code> 运算值为 1 ，得到最小差值 <code>|10 - 1| = 9</code> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>1 &lt;= nums[i] &lt;= 109</code></li><li><code>1 &lt;= k &lt;= 109</code></li><li></li></ul><div class="note info modern"><p>思路：</p></div>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>46级答题卡文件</title>
      <link href="/2024/10/08/46%E7%BA%A7%E7%AD%94%E9%A2%98%E5%8D%A1%E6%96%87%E4%BB%B6/"/>
      <url>/2024/10/08/46%E7%BA%A7%E7%AD%94%E9%A2%98%E5%8D%A1%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>4级答题卡下载：</p></blockquote><p>4级: <a href="/document/CET4.pdf">CET4</a></p><blockquote><p>6级答题卡下载：</p></blockquote><p>6级: <a href="/document/CET6.pdf">CET6</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习&amp;杂记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>起始篇</title>
      <link href="/2024/10/07/start/"/>
      <url>/2024/10/07/start/</url>
      
        <content type="html"><![CDATA[<h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>  今天（2024.10.7）是我20岁生日，我把这个网站搭建起来，作为我的生日礼物。我也是2字开头的人了，未来的日子，将会是我一生的黄金时代，我希望自己能够，每天充满激情的活着，永远年轻，永远热情地对待任何人和任何事情，永远无畏，永远保持独立思考，永远地学习，永远的做我自己！<br>                        —————— 致我20~30岁的人生</p><blockquote><p>休对故人思故国，且将新火试新茶，诗酒趁年华。</p></blockquote><p><img src="/images/10.jpeg" alt="img1"></p>]]></content>
      
      
      <categories>
          
          <category> 碎笔散记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题合集</title>
      <link href="/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2024/10/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="不存在负权边："><a href="#不存在负权边：" class="headerlink" title="不存在负权边："></a>不存在负权边：</h2><h2 id="1-朴素dijkstra算法"><a href="#1-朴素dijkstra算法" class="headerlink" title="1.朴素dijkstra算法"></a>1.朴素dijkstra算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d570c81502a29034d2fd6a13d205fa6.png" alt=""></p><p>思路：（依然是贪心的思想）</p><p>1.初始化距离：dis[1]=0，dis[i]=INF（正无穷）</p><p>2.循环n次：</p><pre><code>    找到当前不在s中的dis最小的点（s表示已经确定最短距离的点（可以开一个st数组表示））    假设找到了t这个点，用这个点更新其他所有点的最短距离：            if dis\[x\]&gt;dis\[t\]+wi（这里wi表示边权）</code></pre><p>实例演示：</p><p>代码如下：</p><p>一些注意细节（用//表示）</p><p>c++版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"><span class="type">int</span>  q[N][N];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j]&amp;&amp;(t==<span class="number">-1</span>||dis[t]&gt;dis[j]))&#123;</span><br><span class="line"><span class="comment">//这里t==-1，其实代表是第一次进入，更新t的值，而后面才开始比较</span></span><br><span class="line"><span class="comment">//t记录的是当前最小的那个节点</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],dis[t]+q[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(q,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> q);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        q[x][y]=<span class="built_in">min</span>(q[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里储存方式用邻接矩阵，主要是因为用于稠密图。图中可能存在重边和自环，<strong>但所有边权均为正值</strong>。算法复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E2%29" alt="\mathcal{O}(n^2)"></p><h2 id="2-堆优化的dijkstra"><a href="#2-堆优化的dijkstra" class="headerlink" title="2.堆优化的dijkstra"></a>2.堆优化的dijkstra</h2><blockquote><p>我们思考一下，上述步骤在哪里可以优化：找到当前不在s中的dis最小的点，我们可以用堆进行优化，优化后复杂度为：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mlogn%29" alt="\mathcal{O}(mlogn)">，堆优化，手写堆和优先队列，但是其实在dijkstra中，不需要手写堆，两个复杂度差不多，不如用优先队列方便。并且，此时为稀疏图，用邻接表更好。</p></blockquote><p> 我们用邻接表现在只需要遍历邻接表中头元素连接的，进行更改，每一次取出队列中的最小值即可</p><p>C++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;<span class="comment">//注意开两倍大小</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; p;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span><span class="comment">//模板，记下来就好了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    p.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=p.<span class="built_in">top</span>();</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> ver=t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver]) <span class="keyword">continue</span>;<span class="comment">//判断是否之前更新过了</span></span><br><span class="line">        st[ver]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[ver];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[ver]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[ver]+w[i];</span><br><span class="line">                p.<span class="built_in">push</span>(&#123;dis[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[n]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//邻接表记得初始化头结点</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">dijkstra</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如果存在负权边："><a href="#如果存在负权边：" class="headerlink" title="如果存在负权边："></a>如果存在负权边：</h2><h2 id="3-bellman-ford"><a href="#3-bellman-ford" class="headerlink" title="3.bellman-ford"></a>3.bellman-ford</h2><p>（有边数限制）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9afe516391ac442fe5133ac5d101280.png" alt=""></p><p>对于边的存储方式不高。故可以用结构体初始化。</p><p>方式：初始化所有点到源点的距离为∞，把源点到自己的距离设置为0，遍历n次；每次遍历m条边，用每一条边去更新各点到源点的距离。在碰到<strong>限制</strong>了最短路径上边的长度时就只能用bellman_ford了。</p><blockquote><p>for n次<br>for 所有边 a,b,w (松弛操作)<br>dis[b] = min(dis[b],back[a] + w)</p><p>//注意：这里的backup非常重要，为了防止串联：（假设限制只能用1条边）</p><p>如下图：如果出现这样，不用之前的备份，就会出现1-&gt;3最近为2，而不是3，所以要备份一下之前的情况，用之前未更新的情况更新下一个节点。</p></blockquote><p> <img src="https://i-blog.csdnimg.cn/blog_migrate/97fecf6087afc576d5952a54f56131d7.png" alt=""></p><p>c++： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">&#125;edge[M];</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> backup[N];</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dis,<span class="keyword">sizeof</span> dis);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">auto</span> e=edge[j];</span><br><span class="line">            dis[e.b]=<span class="built_in">min</span>(dis[e.b],backup[e.a]+e.w);</span><br><span class="line">            <span class="comment">//其实可以利用动态规划</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line">        edge[i]=&#123;x,y,z&#125;;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(dis[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)  <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);<span class="comment">//可能存在负权边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><p>例题：<a href="https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/?envType=daily-question&amp;envId=2024-10-03" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> INFTY = INT_MAX / <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCost</span><span class="params">(<span class="type">int</span> maxTime, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="type">int</span>&gt;&amp; passingFees)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=passingFees.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(maxTime + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, INFTY));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = passingFees[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=maxTime;t++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; edge:edges)&#123;</span><br><span class="line">                <span class="type">int</span> i=edge[<span class="number">0</span>],j=edge[<span class="number">1</span>],time=edge[<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">if</span>(time&lt;=t)&#123;</span><br><span class="line">                f[t][i]=<span class="built_in">min</span>(f[t][i],f[t-time][j]+passingFees[i]);</span><br><span class="line">                f[t][j]=<span class="built_in">min</span>(f[t][j],f[t-time][i]+passingFees[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=INFTY;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxTime;i++)&#123;</span><br><span class="line">            res=<span class="built_in">min</span>(res,f[i][n<span class="number">-1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res==INFTY) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-spfa"><a href="#4-spfa" class="headerlink" title="4.spfa"></a>4.spfa</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91478d6ee11f64a2e7aa53c436ee63f5.png" alt=""></p><p>对bellman-ford的优化，不一定每条边都会更新（spfa算法的想法基础）。</p><blockquote><p>dis[b] = min(dis[b],back[a] + w)</p><p>观察这个式子，只有back[a]变小了，我的后继dis[b]才会变小</p><p>所以，我可以用一个队列，在一次变化中，只要有节点变小了，那么就肯定会影响后继节点，就放入队列之中。只要队列不空，就一直类似于bfs一样进行。</p></blockquote><p> 时间复杂度：一般<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28m%29" alt="\mathcal{O}(m)">，最坏<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28mn%29" alt="\mathcal{O}(mn)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与dijkstra非常相似</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> dis[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-spfa拓展：判断负环"><a href="#5-spfa拓展：判断负环" class="headerlink" title="5.spfa拓展：判断负环"></a>5.spfa拓展：判断负环</h2><blockquote><p>原理：鸽笼原理+三角不等式</p><p>使用spfa算法解决是否存在负环问题</p><p>求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：</p><p>方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环<br>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环  </p><p>每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：<br>在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。</p><p>1、dist[x] 记录虚拟源点到x的最短距离</p><p>2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] &gt;= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p><p>3、若dist[j] &gt; dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步</p><p>注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</p></blockquote><p>引入一个cnt数组，记录每个点经过的边数 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cbb162220a58e90d3b6950f147076b39.png" alt=""></p><p> e.g.</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fb14d0090196cca11c44fec962c7109d.png" alt=""></p><p> 但是，如果从1开始到不了负环地方，那么就会出问题，我们的解决方法是一开始把所有的点都放入队列中：（本质就是以每个点为起点做一遍spfa）</p><blockquote><p>for(int i=1;i&lt;=n;i++){<br>    st[i]=1;<br>    q.push(i);<br>}</p></blockquote><p> 需要再cnt基础上更改的地方：</p><blockquote><p> dis[j]=dis[t]+w[i];<br>                cnt[j]=cnt[t]+1;<br>                if(cnt[j]&gt;=n) return true;</p><p>还有对于cnt数组的初始化，还有把spfa变成布尔函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    st[i]=<span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;dis[t]+w[i])&#123;</span><br><span class="line">                dis[j]=dis[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多源汇最短路问题："><a href="#多源汇最短路问题：" class="headerlink" title="多源汇最短路问题："></a>多源汇最短路问题：</h2><h2 id="6-Floyd算法"><a href="#6-Floyd算法" class="headerlink" title="6.Floyd算法"></a>6.Floyd算法</h2><p>原题：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ad5b1c79035005f56eb9aada883fa579.png" alt=""></p><blockquote><p>原理：基于动态规划：</p><p>d[k,i,j]表示从第i个点出发到达j，只经过1~k个点的最短距离</p><p>状态转移方程：d[k,i,j]=d[k-1,i,k]+d[k-1,k,j]</p><p>发现：k与k-1刚好可以消去这个维度，用一个数组就可以实现</p><p>d[i,j]=d[i,k]+d[k,j]</p></blockquote><p>算法时间复杂度：<img src="https://latex.csdn.net/eq?%5Cmathcal%7BO%7D%28n%5E3%29" alt="\mathcal{O}(n^3)"></p><p>具体：</p><blockquote><p>假设节点序号是从1到n。<br>    假设f[0][i][j]是一个n*n的矩阵，第i行第j列代表从i到j的权值，如果i到j有边，那么其值就为ci,j（边ij的权值）。<br>    如果没有边，那么其值就为无穷大。</p><pre><code>f\[k\]\[i\]\[j\]代表（k的取值范围是从1到n），在考虑了从1到k的节点作为中间经过的节点时，从i到j的最短路径的长度。比如，f\[1\]\[i\]\[j\]就代表了，在考虑了1节点作为中间经过的节点时，从i到j的最短路径的长度。  分析可知，f\[1\]\[i\]\[j\]的值无非就是两种情况，而现在需要分析的路径也无非两种情况，i-&gt;j，i-&gt;1-&gt;j：  【1】f\[0\]\[i\]\[j\]：i-&gt;j这种路径的长度，小于，i-&gt;1-&gt;j这种路径的长度  【2】f\[0\]\[i\]\[1\]+f\[0\]\[1\]\[j\]：i-&gt;1-&gt;j这种路径的长度，小于，i-&gt;j这种路径的长度形式化说明如下：  f\[k\]\[i\]\[j\]可以从两种情况转移而来：  【1】从f\[k−1\]\[i\]\[j\]转移而来，表示i到j的最短路径不经过k这个节点  【2】从f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\]转移而来，表示i到j的最短路径经过k这个节点总结就是：**f\[k\]\[i\]\[j\]=min(f\[k−1\]\[i\]\[j\],f\[k−1\]\[i\]\[k\]+f\[k−1\]\[k\]\[j\])**  从总结上来看，发现f\[k\]只可能与f\[k−1\]有关。</code></pre></blockquote><p>初始化与读入邻接矩阵（存在自环和重边的时候）：</p><blockquote><p>for (int i = 1; i &lt;= n; i ++ )<br>    for (int j = 1; j &lt;= n; j ++ )<br>        if (i == j) d[i][j] = 0;<br>        else d[i][j] = INF;</p><p>while (m — )<br>{<br>    int a, b, c;<br>    scanf(“%d%d%d”, &amp;a, &amp;b, &amp;c);<br>    d[a][b] = min(d[a][b], c);<br>}</p></blockquote><p>c++：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (Q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> t = d[a][b];</span><br><span class="line">        <span class="keyword">if</span> (t &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cpp与java常用的stl总结</title>
      <link href="/2024/10/07/cpp%E4%B8%8Ejava%E5%B8%B8%E7%94%A8%E7%9A%84stl%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/07/cpp%E4%B8%8Ejava%E5%B8%B8%E7%94%A8%E7%9A%84stl%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数组（vector-ArrayList）"><a href="#1-数组（vector-ArrayList）" class="headerlink" title="1.数组（vector/ArrayList）"></a>1.数组（vector/ArrayList）</h2><h3 id="C"><a href="#C" class="headerlink" title="C++:"></a>C++:</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><blockquote><p>vector<int> v;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入操作v.push_back(); //清空操作v.clear();  //求长度操作int len=v.size();v.empty();//判断是否为空 //删除字符串操作v.pop_back(); // 删除向量末尾的元素v.erase(v.begin() + n); // 删除索引为n的元素 //离散化操作+去重sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end()); *在前面还有加上查找：int find(int x)&#123;    return lower_bound(v.begin(), v.end(), x) - v.begin();&#125;  //翻转函数v.reverse(v.begin(),v.end()); //查找函数 用的较少auto it = find(v.begin(), v.end(), target);if (it != v.end()) &#123;    cout &lt;&lt; distance(v.begin(), it) &lt;&lt; endl;&#125;  //自定义排序函数 lambda表达式sort(v.begin(), v.end(), [](int a, int b) &#123;        return a &gt; b; // 左升序 右降序    &#125;); 也可以：bool cmp(int x,int y)&#123;    return x&gt;y;  //降序&#125;bool cmp(int x,int y)&#123;    return x&lt;y;//升序&#125; 还可以：sort(v.begin(), v.end(),greater&lt;int&gt;();//降序sort(v.begin(),v.end(),less&lt;int&gt;());//升序</span></span><br></pre></td></tr></table></figure><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><blockquote><p> list<int> l;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//插入l.push_back(1); //复制l.assign(l1.begin(),l1.end()); //交换l.swap(l1); //大小l.size();l.empty();//判空</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/6acd28357f78439bab81541062e05662.png" alt=""> 排序：</p><p>l.sort();</p><p>第一个元素：l.front();</p><p>最后一个元素：l.back();</p><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a><strong>ArrayList</strong></h4><blockquote><p><strong>List list = new ArrayList();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素list.add(n);list.add(index, n);// 在指定位置插入元素list.set(index,n);// 更新元素// 获取元素list.get(index); // 删除元素list.remove(n);list.remove(index);// 删除指定位置的元素 // 检查元素是否存在list.contains(n);  // 获取ArrayList的大小list.size(); // 清空ArrayListlist.clear(); // 遍历ArrayListfor (int n : list) &#123;    System.out.println(n);&#125; // 使用迭代器遍历Iterator&lt;Interger&gt; iterator = list.iterator();while (iterator.hasNext()) &#123;    int n = iterator.next();    System.out.println(n);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList（双向链表）"><a href="#LinkedList（双向链表）" class="headerlink" title="LinkedList（双向链表）"></a>LinkedList（双向链表）</h4><blockquote><p>LinkedList<String> list = new LinkedList<String>();</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;<span class="comment">// 创建一个空的LinkedListLinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();// 添加元素到列表末尾list.add(&quot;Apple&quot;);// 添加元素到列表开头list.addFirst(&quot;Banana&quot;);// 在指定位置插入元素list.add(1, &quot;Cherry&quot;);// 获取第一个元素String first = list.getFirst();// 获取最后一个元素String last = list.getLast();// 删除第一个元素String removedFirst = list.removeFirst();// 删除最后一个元素String removedLast = list.removeLast();// 删除指定位置的元素String removed = list.remove(1);// 检查元素是否存在boolean contains = list.contains(&quot;Cherry&quot;);// 获取LinkedList的大小int size = list.size();// 清空LinkedListlist.clear();// 遍历LinkedListfor (String fruit : list) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="HashSet（不重复元素的集合）"><a href="#HashSet（不重复元素的集合）" class="headerlink" title="HashSet（不重复元素的集合）"></a>HashSet（不重复元素的集合）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素set.add(n); // 删除元素set.remove(n); // 检查元素是否存在boolean contains = set.contains(n); // 获取HashSet的大小int size = set.size(); // 清空HashSetset.clear(); // 遍历HashSetfor (String fruit : set) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="2-Map"><a href="#2-Map" class="headerlink" title="2.Map"></a>2.Map</h2><h3 id="C-："><a href="#C-：" class="headerlink" title="C++："></a>C++：</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><blockquote><p>map<E,E> m;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map中使用较多1，存储  2，遍历  3，排序 4，查找 //存储,m[key]=value；m[E]=E; //查找auto it = m.find(n); // 查找key为n的元素if (it != m.end()) &#123;    cout&lt;&lt;it-&gt;second&lt;&lt;endl;//输出value值&#125; //删除m.erase(n); // 删除key为n的元素m.erase(m.begin()); // 删除映射中的第一个元素 //统计key个数m.count(&quot;key&quot;);//遍历for(auto k:m) &#123;    cout&lt;&lt;k.first&lt;&lt;&#x27; &#x27;&lt;&lt;k.second&lt;&lt;endl;&#125; //排序 默认按照key值升序排序//在声明的时候添加:greater&lt;int&gt;  就变成降序排序map&lt;E,E,greater&lt;E&gt;&gt; //默认按照key降序排序 //自定义排序主要用于按照value进行排序的情况bool cmp(const pair&lt;int, string&gt;&amp; a, const pair&lt;int, string&gt;&amp; b) &#123;// 自定义比较函数，用于比较map的value    return a.second &lt; b.second; // 按照value的字典序排序&#125; vector&lt;pair&lt;E, E&gt;&gt; v(m.begin(), m.end());//直接把map当作pair类型存到vector中，key-&gt;first  value-seond sort(v.begin(),v.end(),cmp);//现在直接输出v即可/*简易测试代码    m[0]=&quot;1&quot;;    m[2]=&quot;11&quot;;    m[1]=&quot;22&quot;;    vector&lt;PII&gt; v(m.begin(),m.end());    sort(v.begin(),v.end(),cmp);    for(auto k:v) cout&lt;&lt;k.first&lt;&lt;&#x27; &#x27;; //输出的是key     输出:0 2 1  正常输出应该是默认升序0 1 2*/</span></span><br></pre></td></tr></table></figure><h4 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h4><blockquote><p>unordered_map<int,int> data; </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">插入：    <span class="comment">// 方式1: 使用下标运算符[]，如果键不存在，则插入新元素    data[&quot;apple&quot;] = 5;    // 方式2: 使用insert()函数插入一个pair类型的对象    data.insert(pair&lt;string, int&gt;(&quot;banana&quot;, 3));    // 方式3: 使用insert()函数插入一个make_pair()生成的键值对    data.insert(make_pair(&quot;orange&quot;, 7));    // 方式4: 使用insert()函数插入一个初始化列表表示的键值对    data.insert(&#123;&quot;grape&quot;, 2&#125;);    // 方式5: 使用emplace()函数直接构造键值对并插入    data.emplace(&quot;pear&quot;, 4); //从容器中删除。//keydata.erase(&quot;orange&quot;);//迭代器auto it = data.find(&quot;grape&quot;);if (it != data.end()) &#123;    data.erase(it);&#125; clear()：清除容器中的所有元素。 //通过key查找元素auto it = data.find(&quot;apple&quot;);if (it != data.end()) &#123;    // 找到元素，进行操作&#125;//判断key是否存在if (data.count(&quot;banana&quot;)) &#123;    // 键存在&#125; 遍历：for (const auto&amp; pair : data) &#123;    std::cout &lt;&lt; pair.first &lt;&lt; &quot;: &quot; &lt;&lt; pair.second &lt;&lt; std::endl;&#125;for (auto it = data.begin(); it != data.end(); ++it) &#123;    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Java："><a href="#Java：" class="headerlink" title="Java："></a>Java：</h3><h4 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h4><blockquote><p><strong>Map<String, Integer> map = new HashMap<String, Integer>();</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加键值对map.put(n, m); // 获取值map.get(n); // 检查键是否存在map.containsKey(n);//如果有值就用原来的值  没有赋新值(记不得那个操作了)map.containsKey(n) ? map.put(n,map.get(n)+x) : m;  //三元运算符实现 // 删除键值对map.remove(n);map.clear();// 清空HashMap // 获取HashMap的大小map.size(); // 遍历HashMap的键for (String key : map.keySet()) &#123;    System.out.println(&quot;Key: &quot; + key + &quot;, Value: &quot; + map.get(key));&#125; // 遍历HashMap的条目for (HashMap.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;    System.out.println(&quot;Key: &quot; + entry.getKey() + &quot;, Value: &quot; + entry.getValue());&#125;</span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加元素set.add(n); // 删除元素set.remove(n); // 检查元素是否存在boolean contains = set.contains(n); // 获取HashSet的大小int size = set.size(); // 清空HashSetset.clear(); // 遍历HashSetfor (String fruit : set) &#123;    System.out.println(fruit);&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-栈与队列"><a href="#3-栈与队列" class="headerlink" title="3.栈与队列"></a>3.栈与队列</h2><h3 id="C-：-1"><a href="#C-：-1" class="headerlink" title="C++："></a>C++：</h3><h4 id="队列queue"><a href="#队列queue" class="headerlink" title="队列queue"></a>队列queue</h4><blockquote><p>queue<int> q</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队q.push(n);    //获取对头q.front();q.back();//获取队尾 //对头出队q.pop(); //大小q.size();q.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h4 id="优先队列-priority-queue：（插入一个数就排序的队列）"><a href="#优先队列-priority-queue：（插入一个数就排序的队列）" class="headerlink" title="优先队列 priority_queue：（插入一个数就排序的队列）"></a>优先队列 priority_queue：（插入一个数就排序的队列）</h4><blockquote><p> priority_queue<int, vector<int>, less<int>/greater<int>&gt; pq;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队pq.push(n);    //获取对头pq.top();pq.back();//获取队尾 //对头出队pq.pop(); //大小pq.size();pq.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h4 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h4><blockquote><p>stack<int> s;</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈s.push(); //访问s.top();s.pop(); //出栈 //大小s.size();s.empty();//非空判断</span></span><br></pre></td></tr></table></figure><h3 id="java："><a href="#java：" class="headerlink" title="java："></a>java：</h3><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><blockquote><p><strong>Queue queue = new LinkedList&lt;&gt;();</strong></p><p>在Java中，<code>Queue</code> 是一个先进先出（FIFO）的数据结构，它通过接口来实现，常用的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作queue.offer(1); // 出队操作int head = queue.poll(); // 移除并返回队头元素 // 查看队头元素（不出队）int peek = queue.peek(); // 获取队头元素（如果队列为空，则抛出NoSuchElementException）int element = queue.element(); // 获取Queue的大小queue.size(); // 检查Queue是否为空queue.isEmpty(); // 清空Queuequeue.clear(); // 遍历Queuewhile (!queue.isEmpty()) &#123;    System.out.println(queue.poll());&#125; // 使用迭代器遍历Iterator&lt;Integer&gt; iterator = queue.iterator();while (iterator.hasNext()) &#123;    Integer element = iterator.next();    System.out.println(element);&#125;</span></span><br></pre></td></tr></table></figure><h4 id="优先队列："><a href="#优先队列：" class="headerlink" title="优先队列："></a>优先队列：</h4><blockquote><p>PriorityQueue<Integer> queue = new PriorityQueue<Integer>(10, new Comparator<Integer>() {<br>            public int compare(Integer a, Integer b) {<br>                return a - b; //if a&gt;b 则交换，so这是递增序列<br>            }<br>        });</p><p>PriorityQueue<Integer> queue = new PriorityQueue<Integer>(k+1,Comparator.reverseOrder());</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作queue.offer(1); // 出队操作int head = queue.poll(); // 移除并返回队头元素 // // 获取队头元素（不出队）int peek = queue.peek();  // 获取Queue的大小queue.size(); // 检查Queue是否为空queue.isEmpty(); // 清空Queuequeue.clear(); // 遍历Queuewhile (!queue.isEmpty()) &#123;    System.out.println(queue.poll());&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><blockquote><p><strong>Stack stack = new Stack&lt;&gt;();</strong></p><p>在Java中，<code>Stack</code> 是一个后进先出（LIFO）的数据结构，它是通过扩展 <code>Vector</code> 类来实现的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压栈操作stack.push(1); // 出栈操作int top = stack.pop(); // 移除并返回栈顶元素 // 查看栈顶元素（不出栈）int peek = stack.peek(); // 搜索元素，返回元素在栈中的位置（距离栈顶的距离）int index = stack.search(n); // 获取Stack的大小int size = stack.size(); // 检查Stack是否为空boolean isEmpty = stack.isEmpty(); // 清空Stackstack.clear(); // 遍历Stackwhile (!stack.isEmpty()) &#123;    System.out.println(stack.pop());&#125; // 使用迭代器遍历Iterator&lt;Integer&gt; iterator = stack.iterator();while (iterator.hasNext()) &#123;    Integer element = iterator.next();    System.out.println(element);&#125;</span></span><br></pre></td></tr></table></figure><p>一个小技巧：</p>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树</title>
      <link href="/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2024/10/07/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线段树基本知识"><a href="#线段树基本知识" class="headerlink" title="线段树基本知识"></a>线段树基本知识</h2><p><strong>线段树=分治法+二叉树结构+Lazy—Tag技术。</strong></p><p>线段树样式[1,10]：</p><p><img src="https://i-blog.csdnimg.cn/direct/c4ceccc5138f472fb6869dd7b9eda0ff.jpeg" alt=""></p><h2 id="线段树常用操作："><a href="#线段树常用操作：" class="headerlink" title="线段树常用操作："></a>线段树常用操作：</h2><blockquote><p>1.pushup（从下往上）</p><p>1.1(hard) pushdown（懒标记，后面写）</p><p>2.build（建立）</p><p>3.modify（修改）</p><p>4.query(查询)</p></blockquote><p>先来看：</p><h3 id="线段树的build"><a href="#线段树的build" class="headerlink" title="线段树的build"></a>线段树的build</h3><p>前提结论：当做二叉树看：对于编号为x的点：</p><p>父节点：向下取整（x/2），左儿子：2x，右儿子：2x+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//u表示当前线段树一段区间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;<span class="comment">//意味着到达了叶节点</span></span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);<span class="comment">//等于2*u</span></span><br><span class="line">    <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);<span class="comment">//等于2*u+1</span></span><br><span class="line">    <span class="comment">//一般后面接上pushup(u)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询，修改"><a href="#查询，修改" class="headerlink" title="查询，修改"></a>查询，修改</h3><p>原理：都是依次递归，比较简单，详细见后面例题。</p><p>补充：查询最小值（图1），查询区间和（图2）构造的线段树</p><p>图1</p><p><img src="https://i-blog.csdnimg.cn/direct/062c469ee45f47bfb923c25acfb5431b.jpeg" alt=""></p><p>图2</p><p><img src="https://i-blog.csdnimg.cn/direct/8a8942e294ba442fae85db5a0ffc3906.jpeg" alt=""></p><h3 id="线段树要开4倍空间"><a href="#线段树要开4倍空间" class="headerlink" title="线段树要开4倍空间"></a>线段树要开4倍空间</h3><p><a href="https://blog.csdn.net/qq_43803508/article/details/97501894?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172077162316800213020125%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=172077162316800213020125&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-97501894-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%80%E5%9B%9B%E5%80%8D&amp;spm=1018.2226.3001.4187" title="链接1">链接1</a></p><p><a href="https://blog.csdn.net/smoggyxhdz/article/details/78895672" title="链接2">链接2</a></p><h2 id="单点修改："><a href="#单点修改：" class="headerlink" title="单点修改："></a>单点修改：</h2><p><img src="https://i-blog.csdnimg.cn/direct/b3059411c73541dc9f85ff1aa1c6f37b.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, p;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> v;  <span class="comment">// 区间[l, r]中的最大值</span></span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span>  <span class="comment">// 由子节点的信息，来计算父节点的信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].v = <span class="built_in">max</span>(tr[u &lt;&lt; <span class="number">1</span>].v, tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u] = &#123;l, r&#125;;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].v;   <span class="comment">// 树中节点，已经被完全包含在[l, r]中了</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) v = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) v = <span class="built_in">max</span>(v, <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u].v = v;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;p);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            last = <span class="built_in">query</span>(<span class="number">1</span>, n - x + <span class="number">1</span>, n);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, n + <span class="number">1</span>, ((LL)last + x) % p);</span><br><span class="line">            n ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查询区间最大连续子段和，单点修改"><a href="#查询区间最大连续子段和，单点修改" class="headerlink" title="查询区间最大连续子段和，单点修改"></a>查询区间最大连续子段和，单点修改</h2><p><img src="https://i-blog.csdnimg.cn/direct/7a6d8bd767594fd3b278263c5ed859dd.png" alt=""></p><blockquote><p><img src="https://i-blog.csdnimg.cn/direct/6d8d130358184d258fb10dd78c2d3184.png" alt=""></p></blockquote><p> 如何知道上面的东西，我们推导一下，首先我们要求一个区间内最大连续子段和。</p><p><img src="https://i-blog.csdnimg.cn/direct/ecec48e31d2c48b3b75e7b3bcc543bc8.png" alt=""></p><p>那么根据上述操作我们发现我们可以求出tmax，但是引入了lmax与rmax，我们再想办法解决这个问题。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3b0f97492304dd6bcd1f32fd8c5a055.png" alt=""></p><p> 而引入的sum只需要求出区间和就可以。</p><p>则：pushup代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">int</span> sum, lmax, rmax, tmax;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(Node &amp;u, Node &amp;l, Node &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u.sum = l.sum + r.sum;</span><br><span class="line">    u.lmax = <span class="built_in">max</span>(l.lmax, l.sum + r.lmax);</span><br><span class="line">    u.rmax = <span class="built_in">max</span>(r.rmax, r.sum + l.rmax);</span><br><span class="line">    u.tmax = <span class="built_in">max</span>(<span class="built_in">max</span>(l.tmax, r.tmax), l.rmax + r.lmax);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pushup</span>(tr[u], tr[u &lt;&lt; <span class="number">1</span>], tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], w[r], w[r], w[r]&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l == x &amp;&amp; tr[u].r == x) tr[u] = &#123;x, x, v, v, v, v&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, x, v);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &gt; mid) <span class="keyword">return</span> <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> left = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">            <span class="keyword">auto</span> right = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">            Node res;</span><br><span class="line">            <span class="built_in">pushup</span>(res, left, right);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k, x, y;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;k, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, x, y).tmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">modify</span>(<span class="number">1</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="懒标记"><a href="#懒标记" class="headerlink" title="懒标记"></a>懒标记</h2><h3 id="1-Lazy-Tag方法，区间修改"><a href="#1-Lazy-Tag方法，区间修改" class="headerlink" title="1.Lazy-Tag方法，区间修改"></a>1.Lazy-Tag方法，区间修改</h3><blockquote><p>对于区间修改很容易想到解决办法，还是利用线段树的特征：<br>线段树的节点tree[i]记录了区间i的值,那么可以再定义一个tag[i]，用它统一记录区间i的修改，而不是一个个地修改区间内的每个元素，这个方法称为Lazy-Tag(懒惰标记或延迟标记)。</p></blockquote><p>使用Lazy-Tag方法时，若修改的是一个线段区间，就只对这个线段区间进行整体上的<br>修改，其内部每个元素的内容先不做修改，只有当这个线段区间的一致性被破坏时，才把变<br>化值传递给下一层的子区间。每次区间修改的复杂度为O(log2n),一共m次操作，总复杂<br>度为O(mlog2n)。区间i的Lazy操作，用tag[i]记录。</p><h2 id="2-push-down"><a href="#2-push-down" class="headerlink" title="2.push_down"></a>2.push_down</h2><p>传递函数push_down()是处理Lazy-Tag的一个技巧。在进行多次区间修改时，一个<br>节点需要记录多个区间修改，而这些区间修改往往有冲突。所以，Lazy-Tag的主要操作是解决多<br>次区间修改，用push_down()函数完成。首先检查节点p的tag[p],如果有值，说明前面做<br>区间修改时给p打了tag标记，接下来就把tag[p]传给左右子树，然后把tag[p]清零。</p><p>上述操作图示简述：</p><blockquote><p>Struct Node{</p><p>int l,r;</p><p>int sum,add;</p><p>}</p><p>Add-&gt;懒标记</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/fc0069d2261f41b9b27417c635c181bf.png" alt=""></p><p> push_down操作：</p><p>对于节点：root，要将root.add把它pushdown一下：</p><blockquote><p>left.add+=root.add</p><p>left.sum+=(left.r-left.l+1)*root.add</p><p>right.add+=root.add</p><p>right.sum+=(right.r-right.l+1)*root.add</p><p>root.add=0</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/f08de53ace964baab724426bec6ef2b0.png" alt=""></p><p><a href="https://www.luogu.com.cn/problem/P3372" title="【模板】线段树 1 - 洛谷">【模板】线段树 1 - 洛谷</a></p><p>其他同上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    LL sum, add;</span><br><span class="line">&#125;tr[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[u].sum = tr[u &lt;&lt; <span class="number">1</span>].sum + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;root = tr[u], &amp;left = tr[u &lt;&lt; <span class="number">1</span>], &amp;right = tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (root.add)</span><br><span class="line">    &#123;</span><br><span class="line">        left.add += root.add, left.sum += (LL)(left.r - left.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        right.add += root.add, right.sum += (LL)(right.r - right.l + <span class="number">1</span>) * root.add;</span><br><span class="line">        root.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) tr[u] = &#123;l, r, w[r], <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        tr[u] = &#123;l, r&#125;;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].sum += (LL)(tr[u].r - tr[u].l + <span class="number">1</span>) * d;</span><br><span class="line">        tr[u].add += d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// 一定要分裂</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, d);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum += <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> l, r, d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;l, &amp;r);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;d);</span><br><span class="line">            <span class="built_in">modify</span>(<span class="number">1</span>, l, r, d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(<span class="number">1</span>, l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="扫描线法"><a href="#扫描线法" class="headerlink" title="扫描线法"></a>扫描线法</h2><p><a href="https://www.luogu.com.cn/problem/P5490" title="【模板】扫描线 - 洛谷">【模板】扫描线 - 洛谷</a></p><p> 扫描线：</p><h4 id="面积并"><a href="#面积并" class="headerlink" title="面积并"></a>面积并</h4><p>要求两个矩形叠加后的面积和：</p><p><img src="https://i-blog.csdnimg.cn/direct/a21d40eedece44848fd3ab78c8688c91.png" alt=""></p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><p>现在假设，扫描线每次会在碰到竖边的时候停下来，如图。</p><p><img src="https://i-blog.csdnimg.cn/direct/251b5590f2184e3d9f00b91a39e43d7b.png" alt=""></p><h4 id="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"><a href="#为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。" class="headerlink" title="为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。"></a>为了快速计算出截线段长度，可以将横边赋上不同的权值，具体为：对于一个矩形，其左边权值为1，右边权值为−1。</h4><p>然后把所有的横边按照x坐标升序排序。这样，对于每个矩形，扫描线总是会<strong>先碰到左边，然后再碰到右边</strong>。那么就能保证扫描线所截的长度永远非负了。</p><p>这样操作以后，就可以和<strong>线段树</strong>扯上关系。先把所有端点在y轴上离散化（其实就是把所有点的横坐标存到里，然后升序排个序，最后去重）。</p><p><img src="https://i-blog.csdnimg.cn/direct/e3658bbac8cd4dacb96735ec9041874b.png" alt=""><strong>为什么会想到用线段树，</strong>我们来看一下面积表达式：</p><p><img src="https://latex.csdn.net/eq?%5Csum_%7Bi%3D1%7D%5E%7Bn%7Dx%5B0%5D%5Ccdot%20l_i" alt="\sum_{i=1}^{n}x[0]\cdot l_i"></p><p>我们发现x[0]好求，就是想爱你吨数根节点，关键是<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，也就是<img src="https://latex.csdn.net/eq?%5CDelta%20x_i" alt="\Delta x_i">所对应的矩形另一条边的长度。对于一个矩形，其左边权值为1，右边权值为−1。那么我们发现只要定义一个len表示长度，cnt表示次数，只要cnt激活后，就把len激活到<img src="https://latex.csdn.net/eq?l_i" alt="l_i">。</p><p>e.g.蓝色表示第一次更新，紫色表示第二次更新，绿色表示第三次更新。</p><p>我们发现主要求<img src="https://latex.csdn.net/eq?l_i" alt="l_i">，而每次激活的区域刚好可以用线段树去统计，很方便。（即区间查询）</p><p><img src="https://i-blog.csdnimg.cn/direct/eec576e1283848b29814e77656662f07.png" alt=""></p><p>（注意离散化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x1,x2,y1,y2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y1,y2;</span><br><span class="line">    <span class="type">int</span> tag;<span class="comment">//-1,1</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Seg&amp;t) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;seg[N*<span class="number">2</span>];<span class="comment">//区域</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll len,cnt;</span><br><span class="line">&#125;tr[N*<span class="number">8</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ys;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    tr[u]=&#123;l,r,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(ys.<span class="built_in">begin</span>(), ys.<span class="built_in">end</span>(), x) - ys.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tr[u].cnt)&#123;</span><br><span class="line">        tr[u].len=ys[tr[u].r<span class="number">+1</span>]-ys[tr[u].l];<span class="comment">//离散化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(tr[u].l != tr[u].r)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[u].len = tr[u &lt;&lt; <span class="number">1</span>].len + tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>].len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> tr[u].len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=tr[u].l&amp;&amp;tr[u].r&lt;=r)&#123;</span><br><span class="line">        tr[u].cnt+=d;</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = tr[u].r + tr[u].l &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>,l,r,d);<span class="comment">//左边存在点</span></span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid)<span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>,l,r,d);<span class="comment">//右边存在点</span></span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;<span class="comment">//cnt</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">        seg[j++]=&#123;x1,y1,y2,<span class="number">1</span>&#125;;</span><br><span class="line">        seg[j++]=&#123;x2,y1,y2,<span class="number">-1</span>&#125;;</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y1);</span><br><span class="line">        ys.<span class="built_in">push_back</span>(y2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>());</span><br><span class="line">    ys.<span class="built_in">erase</span>(<span class="built_in">unique</span>(ys.<span class="built_in">begin</span>(),ys.<span class="built_in">end</span>()),ys.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(seg,seg+j);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,ys.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i) res+=tr[<span class="number">1</span>].len*(seg[i].x-seg[i<span class="number">-1</span>].x);</span><br><span class="line">        <span class="built_in">modify</span>(<span class="number">1</span>, <span class="built_in">find</span>(seg[i].y1), <span class="built_in">find</span>(seg[i].y2) - <span class="number">1</span>, seg[i].tag);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒标记迭代"><a href="#懒标记迭代" class="headerlink" title="懒标记迭代"></a>懒标记迭代</h2><p><a href="https://www.luogu.com.cn/problem/P3373" title="【模板】线段树 2 - 洛谷">【模板】线段树 2 - 洛谷</a></p><p>与之前不同，这里这么定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p> 重点步骤：</p><p>推公式：</p><p> <img src="https://i-blog.csdnimg.cn/direct/a8284f38938e4ba2b8013b05857d67dc.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    ll sum,add,mul;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,p,m;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    tr[u].sum=(tr[u&lt;&lt;<span class="number">1</span>].sum+tr[u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">(Node &amp;t,<span class="type">int</span> add,<span class="type">int</span> mul)</span></span>&#123;<span class="comment">//懒标记叠加</span></span><br><span class="line">    t.sum = ((ll)t.sum * mul + (ll)(t.r - t.l + <span class="number">1</span>) * add) % p;</span><br><span class="line">    t.mul = (ll)t.mul * mul % p;</span><br><span class="line">    t.add = ((ll)t.add * mul + add) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    <span class="built_in">eval</span>(tr[u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], tr[u].add, tr[u].mul);</span><br><span class="line">    tr[u].add = <span class="number">0</span>, tr[u].mul = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) tr[u]=&#123;l,r,w[r],<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tr[u] = &#123;l, r, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>,l,mid),<span class="built_in">build</span>(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> add,<span class="type">int</span> mul)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) &#123;</span><br><span class="line">        <span class="built_in">eval</span>(tr[u], add, mul);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushdown</span>(u);</span><br><span class="line">        <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) <span class="built_in">modify</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r, add, mul);</span><br><span class="line">        <span class="built_in">pushup</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="keyword">return</span> tr[u].sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(u);</span><br><span class="line">    <span class="type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= mid) sum = <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt; mid) sum = (sum + <span class="built_in">query</span>(u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, l, r)) % p;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="type">int</span> x,y,k;</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,<span class="number">0</span>,k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;</span><br><span class="line">                <span class="built_in">modify</span>(<span class="number">1</span>,x,y,k,<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,x,y)&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>持续更新</strong></p></blockquote><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><h3 id="摘花生"><a href="#摘花生" class="headerlink" title="摘花生"></a>摘花生</h3><p><img src="https://i-blog.csdnimg.cn/direct/7af3aa22023c4a58aafeaf5d32fcb659.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/7a67b415f7d94b7abd7504062e12a7f1.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r,c;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;r,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">               res[i][j]=<span class="built_in">max</span>(res[i<span class="number">-1</span>][j]+w[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);</span><br><span class="line"></span><br><span class="line">       cout&lt;&lt;res[r][c]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最低通行费"><a href="#最低通行费" class="headerlink" title="最低通行费"></a>最低通行费</h3><p><img src="https://i-blog.csdnimg.cn/direct/546cb151875743aeaf9aa397c9791d30.png" alt=""></p><p>注意min的问题一定要考虑边界问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e9;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> w[N][N],res[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">            </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>)  res[i][j]=w[i][j];<span class="comment">//不能直接写res[1][1]=w[1][1],因为for循环里面有res[1][1]=INF;</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            res[i][j]=INF;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i<span class="number">-1</span>][j]+w[i][j]);<span class="comment">// 只有不在第一行的时候，才可以从上面过来</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;<span class="number">1</span>) res[i][j]=<span class="built_in">min</span>(res[i][j],res[i][j<span class="number">-1</span>]+w[i][j]);<span class="comment">// 只有不在第一列的时候，才可以从左面过来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res[r][r]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方格取数（洛谷）"><a href="#方格取数（洛谷）" class="headerlink" title="方格取数（洛谷）"></a>方格取数（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1004" title="[NOIP2000 提高组] 方格取数 - 洛谷">[NOIP2000 提高组] 方格取数 - 洛谷</a></p><p><img src="https://i-blog.csdnimg.cn/direct/c2a0bb9f4af6499c8f30ad928e7b0b16.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/f2d1b3bdbe9c46ab8d70d05c6e93dda6.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x,y,r;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;r==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        w[x][y]=r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=n+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="number">1</span>;i1&lt;=n;i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="number">1</span>;i2&lt;=n;i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="keyword">if</span>(j1&gt;=<span class="number">1</span>&amp;&amp;j1&lt;=n&amp;&amp;j2&gt;=<span class="number">1</span>&amp;&amp;j2&lt;=n)&#123;</span><br><span class="line">                    <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                    <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                    <span class="type">int</span> &amp;x = f[k][i1][i2];</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1 - <span class="number">1</span>][i2] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2 - <span class="number">1</span>] + t);</span><br><span class="line">                    x = <span class="built_in">max</span>(x, f[k - <span class="number">1</span>][i1][i2] + t);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n + n][n][n]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="传纸条（洛谷）"><a href="#传纸条（洛谷）" class="headerlink" title="传纸条（洛谷）"></a>传纸条（洛谷）</h3><p> <a href="https://www.luogu.com.cn/problem/P1006" title="[NOIP2008 提高组] 传纸条 - 洛谷">[NOIP2008 提高组] 传纸条 - 洛谷</a></p><p>注意：此题是正方形，所以i1,i2的限制只有1&lt;=i1,i2&lt;=n。下面一道题变成长方形(m*n)的时候，就会有限制：</p><p><img src="https://latex.csdn.net/eq?1%5Cleqslant%20i1%20%5Cleqslant%20n%20%5Cquad%201%5Cleqslant%20k-i1%5Cleqslant%20m%5CRightarrow%20%5Cquad%20%5Cleft%5C%7B%5Cbegin%7Bmatrix%7D%201%5Cleqslant%20i1%20%5Cleqslant%20n%5C%5C%20k-m%5Cleqslant%20i1%20%5Cleqslant%20k-1%20%5Cend%7Bmatrix%7D%5Cright." alt="1\leqslant i1 \leqslant n \quad 1\leqslant k-i1\leqslant m\Rightarrow \quad \left\{\begin{matrix} 1\leqslant i1 \leqslant n\\ k-m\leqslant i1 \leqslant k-1 \end{matrix}\right."></p><p><img src="https://latex.csdn.net/eq?summary%20%5CRightarrow%20max%281%2Ck-m%29%5Cleqslant%20i1%20%5Cleqslant%20min%28n%2Ck-1%29" alt="summary \Rightarrow max(1,k-m)\leqslant i1 \leqslant min(n,k-1)"></p><p>同理，i2范围与i1一致</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[N*<span class="number">2</span>][N][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">2</span>;k&lt;=m+n;k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i1=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i1&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i1++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i2=<span class="built_in">max</span>(<span class="number">1</span>,k-n);i2&lt;=<span class="built_in">min</span>(k<span class="number">-1</span>,m);i2++)&#123;</span><br><span class="line">                <span class="type">int</span> j1=k-i1,j2=k-i2;</span><br><span class="line">                <span class="type">int</span> t=w[i1][j1];</span><br><span class="line">                <span class="keyword">if</span>(i1!=i2) t+=w[i2][j2];</span><br><span class="line">                <span class="type">int</span> &amp;x=f[k][i1][i2];</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2<span class="number">-1</span>]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1][i2]+t);</span><br><span class="line">                x=<span class="built_in">max</span>(x,f[k<span class="number">-1</span>][i1<span class="number">-1</span>][i2<span class="number">-1</span>]+t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;f[m+n][m][m];<span class="comment">//注意两个路线横坐标都是n</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><h3 id="（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）"><a href="#（-）最长上升子序列（洛谷）-amp-最长递增子序列（leetcode）" class="headerlink" title="（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）"></a>（*****）最长上升子序列（洛谷）&amp;最长递增子序列（leetcode）</h3><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/" title="300.最长递增子序列">300.最长递增子序列</a></p><p><strong>dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度</strong></p><p>状态转移方程：</p><p>位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值。</p><p>所以：if (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1);</p><p><img src="https://i-blog.csdnimg.cn/direct/b26f61b3a65d4e4fb5c88c9b65533cdd.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/00230658077d4e9397751278591a94a1.png" alt=""></p><p> 洛谷题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;a[i])&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    cout&lt;&lt;res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode题解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">                    dp[i]=<span class="built_in">max</span>(dp[i],dp[j]<span class="number">+1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode674-最长连续递增序列"><a href="#leetcode674-最长连续递增序列" class="headerlink" title="leetcode674. 最长连续递增序列"></a>leetcode674. 最长连续递增序列</h3><p> <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/description/" title="674. 最长连续递增序列">674. 最长连续递增序列</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i]=dp[i<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">             <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode718-最长重复子数组"><a href="#leetcode718-最长重复子数组" class="headerlink" title="leetcode718. 最长重复子数组"></a>leetcode718. 最长重复子数组</h3><p><a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/description/" title="最长重复子数组">最长重复子数组</a></p><blockquote><p>定义dp[i][j]为 以下标i为结尾的A，和以下标j 为结尾的B，最长重复子数组长度。</p><p>确定递推公式：</p><p>根据dp[i][j]的定义，dp[i][j]的状态只能由dp[i - 1][j - 1]推导出来。</p><p>即当A[i - 1] 和B[j - 1]相等的时候，<strong>dp[i][j] = dp[i - 1][j - 1] + 1;</strong></p><p><strong>例如：【1,2,3,4】与【9,1,2,3】</strong></p><p><strong>当i=1，j=2时候，相等，由于连续，那么i退一格，j退一格，刚好就是dp【i】【j】的更新。</strong></p><p>根据递推公式可以看出，遍历i 和 j 要从1开始！</p></blockquote><p>这里代码用：i-1是为了方便，不想初始化，直接把0视为无用位，从1开始推。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span> (nums<span class="number">1.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums<span class="number">2.</span><span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums<span class="number">1.</span><span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums<span class="number">2.</span><span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &gt; result) result = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷"><a href="#（-）leetcode最长公共子序列（LCS）-amp-最长上升子序列-洛谷" class="headerlink" title="（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷"></a>（*****）leetcode最长公共子序列（LCS）  &amp;最长上升子序列 - 洛谷</h3><p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/" title="leetcode最长公共子序列">leetcode最长公共子序列</a></p><blockquote><p>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同</p><p>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;</p><p>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。</p><p>即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</p><p>找子问题，</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/c32ead5d55ba4e2fa63d42d4c8083f8c.png" alt=""></p><blockquote><p> ++++++++++其实就是x与y的问题，我们已知x,y前面的状态确定：</p><p>If x==y    </p><p>那么就是在原来的基础上（i-1,j-1)</p><p>基础上+1即可</p><p>Else(x!=y) 那么就是说我既然是对x,y的讨论</p><p>那么直接看我不要x，还是不要y那个子串</p><p>更长，那么我就让这个更长的记录到这里</p><p>（我们默认了前面状态已知，只需要考虑</p><p>x,y，为什么不考虑把x，y都舍弃，因为</p><p>已经包含在内了（看dp数组的定义）</p></blockquote><p> 举个例子：</p><p> *（dp[2][4],dp[3][3]在之前已经求过了）</p><p><img src="https://i-blog.csdnimg.cn/direct/dbec674c00114527b46ec6332f547d90.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=text<span class="number">1.</span><span class="built_in">size</span>(),n2=text<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>]==text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在洛谷：</p><p><a href="https://www.luogu.com.cn/problem/B3637" title="最长上升子序列 - 洛谷">最长上升子序列 - 洛谷</a></p><p>用刚刚的思路，会卡你：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5000</span>],b[<span class="number">5000</span>],f[<span class="number">5000</span>][<span class="number">5000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)</span><br><span class="line">      &#123;</span><br><span class="line">      <span class="keyword">if</span> ((i==<span class="number">0</span>)||(j==<span class="number">0</span>)) &#123;</span><br><span class="line">      f[i][j]=<span class="number">0</span>;<span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      <span class="keyword">if</span> (a[i]==b[j]) f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i]!=b[j]) f[i][j]=<span class="built_in">max</span>(f[i][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/6124c9d7d33b4f96873c2583634abc63.png" alt=""></p><p>用优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>],b[<span class="number">100001</span>],map[<span class="number">100001</span>],f[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);map[a[i]]=i;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);f[i]=<span class="number">0x7fffffff</span>;&#125;</span><br><span class="line"><span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>,r=len,mid;</span><br><span class="line"><span class="keyword">if</span>(map[b[i]]&gt;f[len])f[++len]=map[b[i]];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">    mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(f[mid]&gt;map[b[i]])r=mid;</span><br><span class="line"><span class="keyword">else</span> l=mid<span class="number">+1</span>; </span><br><span class="line">&#125;</span><br><span class="line">f[l]=<span class="built_in">min</span>(map[b[i]],f[l]);</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;len;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/06a5f48006ad40619df8d146e3c88ce4.png" alt=""></p><h3 id="leetcode1035-不相交的线"><a href="#leetcode1035-不相交的线" class="headerlink" title="leetcode1035. 不相交的线"></a>leetcode1035. 不相交的线</h3><p><a href="https://leetcode.cn/problems/uncrossed-lines/description/" title="1035. 不相交的线">1035. 不相交的线</a></p><p>仔细分析此题，发现与上面那道题一模一样，就是求两个数组的LCS。</p><p>代码一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=nums<span class="number">1.</span><span class="built_in">size</span>(),n2=nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>]==nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode53-最大子数组和"><a href="#leetcode53-最大子数组和" class="headerlink" title="leetcode53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></h3><p> <a href="https://leetcode.cn/problems/maximum-subarray/description/" title="leetcode53. 最大子数组和">leetcode53. 最大子数组和</a></p><p><strong>dp[i]：包括下标i（以nums[i]为结尾）的最大连续子序列和为dp[i]</strong>。</p><p>dp[i]只有两个方向可以推出来：</p><ul><li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li><li>nums[i]，即：从头开始计算当前连续子序列和</li></ul><p>遍历所以的dp找到最大的输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">-1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            res=<span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode392-判断子序列"><a href="#leetcode392-判断子序列" class="headerlink" title="leetcode392. 判断子序列"></a>leetcode392. 判断子序列</h3><p><a href="https://leetcode.cn/problems/is-subsequence/description/" title="392. 判断子序列">392. 判断子序列</a></p><p>与LCS一模一样，就是判断一下是否等于s的长度即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1=s.<span class="built_in">size</span>(),n2=t.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n1<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n2<span class="number">+1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>]==t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[n1][n2]==n1)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有更简洁的写法：</p><p>直接扫描string t，然后相同就++i，如果有i==t.size()，那么就有。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == c &amp;&amp; ++i == s.<span class="built_in">length</span>()) &#123; <span class="comment">// 所有字符匹配完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// s 是 t 的子序列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode115-不同的子序列"><a href="#leetcode115-不同的子序列" class="headerlink" title="leetcode115. 不同的子序列"></a>leetcode115. 不同的子序列</h3><p><a href="https://leetcode.cn/problems/distinct-subsequences/description/" title="leetcode115. 不同的子序列">leetcode115. 不同的子序列</a></p><blockquote><p>dp[i][j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i][j]。</p><p>这一类问题，基本是要分析两种情况</p><ul><li>s[i - 1] 与 t[j - 1]相等</li><li>s[i - 1] 与 t[j - 1] 不相等</li></ul></blockquote><p> s[i - 1] 与 t[j - 1]相等</p><p><img src="https://i-blog.csdnimg.cn/direct/5c931c26aa4a43bb83da5b3338b84f0b.png" alt=""></p><p>s[i - 1] 与 t[j - 1] 不相等：</p><p>dp[i][j] = dp[i - 1][j];</p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][t.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=t.length();j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>)==t.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="leetcode583-两个字符串的删除操作"><a href="#leetcode583-两个字符串的删除操作" class="headerlink" title="leetcode583. 两个字符串的删除操作"></a>leetcode583. 两个字符串的删除操作</h3><p> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/description/" title="leetcode583. 两个字符串的删除操作">leetcode583. 两个字符串的删除操作</a></p><blockquote><p>dp[i][j]：以i-1为结尾的字符串word1，和以j-1位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</p><p><strong>递推：</strong></p><ul><li>当word1[i - 1] 与 word2[j - 1]相同的时候</li><li>当word1[i - 1] 与 word2[j - 1]不相同的时候</li></ul><p>当word1[i - 1] 与 word2[j - 1]相同的时候，dp[i][j] = dp[i - 1][j - 1];</p><p>当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：</p><p>情况一：删word1[i - 1]，最少操作次数为dp[i - 1][j] + 1</p><p>情况二：删word2[j - 1]，最少操作次数为dp[i][j - 1] + 1</p><p>情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1][j - 1] + 2</p><p>那最后当然是取最小值，所以当word1[i - 1] 与 word2[j - 1]不相同的时候，递推公式：dp[i][j] = min({dp[i - 1][j - 1] + 2, dp[i - 1][j] + 1, dp[i][j - 1] + 1});</p><p>因为 dp[i][j - 1] + 1 = dp[i - 1][j - 1] + 2，所以递推公式可简化为：dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);</p><p>这里可能不少录友有点迷糊，从字面上理解 就是 当 同时删word1[i - 1]和word2[j - 1]，dp[i][j-1] 本来就不考虑 word2[j - 1]了，那么我在删 word1[i - 1]，是不是就达到两个元素都删除的效果，即 dp[i][j-1] + 1。</p><p><strong>dp数组如何初始化：</strong></p><p>从递推公式中，可以看出来，dp[i][0] 和 dp[0][j]是一定要初始化的。</p><p>dp[i][0]：word2为空字符串，以i-1为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][0] = i。</p><p>dp[0][j]的话同理</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/19ad34e5089f4f9bbcd6c86435f8d9c2.png" alt=""></p><p><img src="https://i-blog.csdnimg.cn/direct/7cdce9d8f60b48e79f352db055469971.png" alt=""> java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[word1.length()+<span class="number">1</span>][word2.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=i;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=word2.length();i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=word1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=word2.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i-<span class="number">1</span>)==word2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>,Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>,dp[i][j-<span class="number">1</span>]+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（-）leetcode72-编辑距离"><a href="#（-）leetcode72-编辑距离" class="headerlink" title="（*****）leetcode72. 编辑距离"></a>（*****）leetcode72. 编辑距离</h3><p><a href="https://leetcode.cn/problems/edit-distance/description/" title="leetcode72. 编辑距离">leetcode72. 编辑距离</a></p><blockquote><p><strong>dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (word1[i - 1] == word2[j - 1])</span><br><span class="line">    不操作</span><br><span class="line"><span class="keyword">if</span> (word1[i - 1] != word2[j - 1])</span><br><span class="line">    增</span><br><span class="line">    删</span><br><span class="line">    换</span><br></pre></td></tr></table></figure><p> <code>if (word1[i - 1] == word2[j - 1])</code> 那么说明不用任何编辑，<code>dp[i][j]</code> 就应该是 <code>dp[i - 1][j - 1]</code>，即<code>dp[i][j] = dp[i - 1][j - 1];</code></p><p><code>if (word1[i - 1] != word2[j - 1])</code>，此时就需要编辑了</p></blockquote><p><img src="https://i-blog.csdnimg.cn/direct/e0fb61d7ba29424c914ce1448042d83b.png" alt=""></p><p>java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = Math.min(insert, Math.min(delete, replace));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c1 = word1.toCharArray(), c2 = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> c1.length, n = c2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftUp</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">backup</span> <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[j] = leftUp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = Math.min(leftUp, Math.min(dp[j], dp[j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                leftUp = backup;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共上升子序列"><a href="#最长公共上升子序列" class="headerlink" title="最长公共上升子序列"></a>最长公共上升子序列</h3><p><img src="https://i-blog.csdnimg.cn/direct/62f8aab7d3604a71a391af377de2d4f0.png" alt=""></p><h3 id="怪盗基德的帽子"><a href="#怪盗基德的帽子" class="headerlink" title="怪盗基德的帽子"></a>怪盗基德的帽子</h3><p><img src="https://i-blog.csdnimg.cn/direct/16510be1060f48de83f2c47b76f25628.png" alt="">​</p><p> 本质：做了正反两次的LIS（最长上升子序列），进行比较大小，找出最长递增子序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N],f[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        cin&gt;&gt;n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line">        <span class="comment">//正向</span></span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//反向</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">           f[i]=<span class="number">1</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=n;j&gt;i;j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(w[j]&lt;w[i])&#123;</span><br><span class="line">                   f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">       &#125;</span><br><span class="line">        cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="登山"><a href="#登山" class="headerlink" title="登山"></a>登山</h3><p><img src="https://i-blog.csdnimg.cn/direct/5a91eba5e28042bbad2d940aef4f220c.png" alt="">​</p><p>与上题一模一样，上题是单边找最大，这题是把两边加起来－1就可以，本质一样。</p><p><img src="https://i-blog.csdnimg.cn/direct/e7f393c4178d49feb69dfc8ca5012554.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合唱队形（洛谷）"><a href="#合唱队形（洛谷）" class="headerlink" title="合唱队形（洛谷）"></a>合唱队形（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P1091" title="[NOIP2004 提高组] 合唱队形 - 洛谷">[NOIP2004 提高组] 合唱队形 - 洛谷</a></p><p> 和登山一模一样，但是记得减一就好，模型就是：求前后的最大上升子序列，减去总共的就是。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n;i; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt; i; j -- )</span><br><span class="line">            <span class="keyword">if</span> (h[i] &gt; h[j])</span><br><span class="line">                g[i] = <span class="built_in">max</span>(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i ++ ) res = <span class="built_in">max</span>(res, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> k=n-res;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友好城市（洛谷）"><a href="#友好城市（洛谷）" class="headerlink" title="友好城市（洛谷）"></a>友好城市（洛谷）</h3><p><a href="https://www.luogu.com.cn/problem/P2782" title="友好城市 - 洛谷">友好城市 - 洛谷</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/838bd7f152f4484ca7737d020a0a96e8.png" alt="">​</p><p> <img src="https://latex.csdn.net/eq?if%20%5Cquad%20index_1%3Cindex_2%2C%20val_1%3Cval_2%20%2Cthen%20%5C%3A%20OK" alt="if \quad index_1&lt;index_2, val_1&lt;val_2 ,then \: OK"></p><p>单调上升子序列，只有满足如上要求才可以</p><p>所以如果有一个序列排好序，则它一定是递增的，只要知道另一个对应的序列</p><p>的最长上升子序列，就是它最大的不重叠数量。</p><p>方法与思路：（举个栗子，图示）</p><p><img src="https://i-blog.csdnimg.cn/direct/99554a0536aa4e84ac1aa8f88fab466c.png" alt="">​</p><p> 用这样的想法我们能得到如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(w,w+n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        f[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[j].second&lt;w[i].second)&#123;</span><br><span class="line">                f[i]=<span class="built_in">max</span>(f[i],f[j]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res=<span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会发现如下的东西：</p><p><img src="https://i-blog.csdnimg.cn/direct/df64d4f3c36f4e01afd5365545fc58e7.png" alt="">​</p><p> 超时：</p><p>我刚刚利用动态规划复杂度为<img src="https://latex.csdn.net/eq?O%28N%5E2%29" alt="O(N^2)">，我们需要另外找一种方案去优化：</p><p>法1：</p><p>在我们每处理数列中的一位时，我们都要遍历数组找到值小于当前数中的f值的最大值，再用其加一作为现数字的值。如下，就是我们每一次记录的f【i】的值。</p><p><img src="https://i-blog.csdnimg.cn/direct/13e62770c80244c59383f98891808ed3.png" alt="">​</p><p>那么，如果我们维护一个取值集合，储存可能的最优解， 就可以优化算法的时间复杂度。</p><p>将一个数放入取值集合的条件是什么？如果两个数a、b ，当他们的f值相同，且a&lt;b,那么a对于后来的数来说，显然比b优。（运用了优先队列的思想）。例如：图中3,1 用1一定比用3好，因为更小。</p><p>我们用函数图像能更直观理解：</p><p><img src="https://i-blog.csdnimg.cn/direct/e485284933e14bfa9947f69052287ce8.png" alt="">​</p><p>所以我们只需要那么我们储存下对每一个f值来说的最小原数字值，在处理完新数字后将新数字与与其f值相同的数字比较大小，若小于则更新，若大于接在e数组后面。</p><p>每次我们都查找第一个比当前数大的位置在哪里，用lower_bound即可（二分法）。</p><p><img src="https://i-blog.csdnimg.cn/direct/df4ab32830814ccdac0a73d19f87fdae.png" alt="">​</p><p>用p做记录，记录尾插次数，也就是最长递增子序列，此时优化为了：<img src="https://latex.csdn.net/eq?O%28nlog_n%29" alt="O(nlog_n)"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line">pii w[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pii x,pii y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.first&lt;y.first;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        w[i]=&#123;x,y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(w,w+n,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(e[p]&lt;w[i].second) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            e[p]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            e[<span class="built_in">lower_bound</span>(e,e+p,w[i].second)-e]=w[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;p&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就会得到：</p><p><img src="https://i-blog.csdnimg.cn/direct/51132788070b4f73a28a6ae8285f194f.png" alt="">​</p><h3 id="最大上升子序列和"><a href="#最大上升子序列和" class="headerlink" title="最大上升子序列和"></a>最大上升子序列和</h3><p> <img src="https://i-blog.csdnimg.cn/direct/046762182ae340589a567ec599ec8043.png" alt="">​</p><p>只是在第一个最长上升子序列上面加上了w【i】 ，几乎没有什么变化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>],f[<span class="number">1005</span>],ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = a[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[i],f[j] + a[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题分析："><a href="#背包问题分析：" class="headerlink" title="背包问题分析："></a>背包问题分析：</h2><h3 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/b3c245b017944a528eb6ff894c1abc63.png" alt="">​</p><p><img src="https://i-blog.csdnimg.cn/direct/cea08c3d986e4813ad836065be610623.png" alt="">​</p><p>二维： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> v[MAXN];    <span class="comment">// 体积</span></span><br><span class="line"><span class="type">int</span> w[MAXN];    <span class="comment">// 价值 </span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];  <span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;   </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) </span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">            <span class="keyword">else</span>    </span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;           </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 滚动数组一维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-416-分割等和子集"><a href="#Leetcode-416-分割等和子集" class="headerlink" title="Leetcode 416. 分割等和子集"></a>Leetcode 416. 分割等和子集</h4><p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/" title="Leetcode 416. 分割等和子集">Leetcode 416. 分割等和子集</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> N=<span class="number">20001</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) res+=nums[i];</span><br><span class="line">        <span class="keyword">if</span>(res%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=res/<span class="number">2</span>;j;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=nums[i])&#123;</span><br><span class="line">                    dp[j]=<span class="built_in">max</span>(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j]=dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[res/<span class="number">2</span>]==res/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-1049-最后一块石头的重量-II"><a href="#Leetcode-1049-最后一块石头的重量-II" class="headerlink" title="Leetcode 1049. 最后一块石头的重量 II"></a>Leetcode 1049. 最后一块石头的重量 II</h4><p><a href="https://leetcode.cn/problems/last-stone-weight-ii/description/" title="Leetcode 1049. 最后一块石头的重量 II">Leetcode 1049. 最后一块石头的重量 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  <span class="type">const</span> <span class="type">int</span> N=<span class="number">15001</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp[N];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++) res+=stones[i];</span><br><span class="line">        <span class="type">int</span> r=res/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;stones.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=r;j&gt;=stones[i];j--)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j],dp[j-stones[i]]+stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (res-dp[r])-dp[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-494-目标和"><a href="#Leetcode-494-目标和" class="headerlink" title="Leetcode 494. 目标和"></a>Leetcode 494. 目标和</h4><p><a href="https://leetcode.cn/problems/target-sum/description/" title="Leetcode 494. 目标和">Leetcode 494. 目标和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++) sum+=nums[i];</span><br><span class="line">        <span class="type">int</span> z=(sum+target);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="built_in">abs</span>(target)||z%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> pos=z/<span class="number">2</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(pos + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=pos;j&gt;=nums[i];j--)&#123;</span><br><span class="line">                dp[j]+=dp[j-nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[pos];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-474-一和零"><a href="#Leetcode-474-一和零" class="headerlink" title="Leetcode 474.一和零"></a><a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></h4><p> <a href="https://leetcode.cn/problems/ones-and-zeroes/description/" title="Leetcode 474.一和零">Leetcode 474.一和零</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMaxForm</span><span class="params">(vector&lt;string&gt;&amp; strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (n + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">for</span> (string str : strs) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">            <span class="type">int</span> oneNum = <span class="number">0</span>, zeroNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zeroNum++;</span><br><span class="line">                <span class="keyword">else</span> oneNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt;= zeroNum; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= oneNum; j--) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="完全背包："><a href="#完全背包：" class="headerlink" title="完全背包："></a>完全背包：</h3><p><img src="https://i-blog.csdnimg.cn/direct/fb1fc89a9c1f4a9692cb69e20a696513.png" alt="">​</p><p>优化：</p><p><img src="https://i-blog.csdnimg.cn/direct/979fc6aaf49044b3bc9739faf198ebf6.png" alt="">​ <img src="https://i-blog.csdnimg.cn/direct/27e670c68bec4dadbc1177b9fc157c8c.png" alt="">​</p><blockquote><p>总结：</p><p>f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//01背包</p><p>f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);//完全背包问题</p></blockquote><p> 二维：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &lt;= j)</span><br><span class="line">                f[i][j] =<span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - v[i]] + w[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>滚动数组1维优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[<span class="number">1001</span>],n,v,c[<span class="number">1001</span>],w[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; c[i] &gt;&gt; w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> vv = v;vv &gt;= c[i];vv--)</span><br><span class="line">f[vv] = <span class="built_in">max</span>(f[vv],f[vv - c[i]] + w[i]);</span><br><span class="line"><span class="comment">//这里要正序，你可以理解为：f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);</span></span><br><span class="line"><span class="comment">//这里是i的f,而不是i-1的，所以要与01背包不同（i-1）则需要逆序</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f[v];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：多重背包的遍历顺序</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p>for  i：物品</p><pre><code>  for j:背包大小</code></pre><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><p>for  j：背包大小</p><pre><code>  for i:物品</code></pre><p>为什么：第一个理解成固定一个物品，再遍历背包看是否能满足，第二个应该是固定一个背包空间，遍历物品看是否能满足。</p><p>例如背包大小为3，·物品有1,2</p><p>如果按照第一种方式：先看1，再加入2，只会有{1,2}这种</p><p>如果按照第一种方式：背包大小为0，背包大小为1，背包大小为2，只就有{1,2}，{2,1}这两种</p><p>所以：第一种求的是组合数，第二种求的是排列数。</p><p>518,377就是上述两种不一样的方法。</p></blockquote><h4 id="Leetcde-518-零钱兑换-II"><a href="#Leetcde-518-零钱兑换-II" class="headerlink" title="Leetcde 518. 零钱兑换 II"></a>Leetcde 518. 零钱兑换 II</h4><p><a href="https://leetcode.cn/problems/coin-change-ii/" title="Leetcde 518. 零钱兑换 II">Leetcde 518. 零钱兑换 II</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">change</span><span class="params">(<span class="type">int</span> amount, vector&lt;<span class="type">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]+=dp[j-coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Leetcode-377-组合总数Ⅳ"><a href="#Leetcode-377-组合总数Ⅳ" class="headerlink" title="Leetcode 377.组合总数Ⅳ"></a>Leetcode 377.组合总数Ⅳ</h4><p><a href="https://leetcode.cn/problems/combination-sum-iv/description/" title="Leetcode 377.组合总数Ⅳ">Leetcode 377.组合总数Ⅳ</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">            <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=target;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j&gt;=nums[i]&amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]])</span><br><span class="line">                    dp[j]+=dp[j-nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode-322-零钱兑换"><a href="#leetcode-322-零钱兑换" class="headerlink" title="leetcode 322.零钱兑换"></a>leetcode 322.零钱兑换</h4><p><a href="https://leetcode.cn/problems/coin-change/submissions/556660704/" title="322.零钱兑换">322.零钱兑换</a></p><p><img src="https://i-blog.csdnimg.cn/direct/8885a71b3d3041d584276ef96193276d.jpeg" alt="">​</p><p>主要在于递推公式，但是不同的是初始化要一个特别大的数字，然后dp[0]=0;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> INT_INF=<span class="number">1e9</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount<span class="number">+1</span>,INT_INF)</span></span>;</span><br><span class="line">        <span class="type">int</span> n=coins.<span class="built_in">size</span>();</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=coins[i];j&lt;=amount;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-coins[i]]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[amount]==INT_INF) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode279-完全平方数"><a href="#leetcode279-完全平方数" class="headerlink" title="leetcode279.完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="leetcode279.完全平方数">leetcode279.完全平方数</a></h4><p> <a href="https://leetcode.cn/problems/perfect-squares/submissions/556666198/" title="279.完全平方数">279.完全平方数</a></p><p>我们抽象以下：</p><p><img src="https://latex.csdn.net/eq?x%3Da_1%5E2&plus;a_2%5E2&plus;a_3%5E2&plus;...&plus;a_n%5E2" alt="x=a_1^2+a_2^2+a_3^2+...+a_n^2"></p><p>那么立马就变成完全背包问题：</p><p> 物品就是：从1开始一直到100（数据范围），重量就是<img src="https://latex.csdn.net/eq?i%5E2" alt="i^2">，价值就是i，然后dp[j]表示，表示第j个数需要的最少的数据个数。</p><p>和上面那个题一模一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="built_in">pow</span>(i,<span class="number">2</span>);j&lt;=n;j++)&#123;</span><br><span class="line">                dp[j]=<span class="built_in">min</span>(dp[j],dp[j-<span class="built_in">pow</span>(i,<span class="number">2</span>)]<span class="number">+1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="leetcode129-单词拆分"><a href="#leetcode129-单词拆分" class="headerlink" title="leetcode129.单词拆分"></a>leetcode129.单词拆分</h4><p><a href="https://leetcode.cn/problems/word-break/description/" title="129.单词拆分">129.单词拆分</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;string&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;<span class="comment">//为了find到截取的字符串</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">v</span><span class="params">(s.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)&#123;  <span class="comment">//字符从0~i开始遍历，指针为i,背包大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;   <span class="comment">//i-j用来截取，只有当v[j]==1并且存在截取的子串时才可以</span></span><br><span class="line">            string sub=s.<span class="built_in">substr</span>(j,i-j);</span><br><span class="line">                <span class="keyword">if</span>(v[j]&amp;&amp;wordSet.<span class="built_in">find</span>(sub)!=wordSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    v[i]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="多重背包："><a href="#多重背包：" class="headerlink" title="多重背包："></a>多重背包：</h3><h4 id="多重背包看做01背包"><a href="#多重背包看做01背包" class="headerlink" title="多重背包看做01背包"></a>多重背包看做01背包</h4><p><strong>这个思路就是把多重背包看成是01背包：</strong>  </p><p><img src="https://i-blog.csdnimg.cn/direct/8ac2dfb8d2314c0cbb2cceeb06379f19.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,vv,s[<span class="number">101</span>],v[<span class="number">101</span>],w[<span class="number">101</span>],dp[<span class="number">101</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; vv;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">//遍历是第几个物品</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; s[i];j++)<span class="comment">//遍历第i个物品用了j遍</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = vv;k &gt;= v[i];k--)</span><br><span class="line"><span class="comment">//逆序，遍历从最大背包体积开始，背包大小为k是，向背包放物品。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[k] = <span class="built_in">max</span>(dp[k],dp[k - v[i]] + w[i]);<span class="comment">//递推公式，体积为k时，不选这个物品，就是继承之前的i-1的dp[k]，选这个物品，就是背包大小减去v[i]，加上w[i]的价值。</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[vv];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包二进制优化"><a href="#多重背包二进制优化" class="headerlink" title="多重背包二进制优化"></a>多重背包二进制优化</h4><p>二进制怎么表示这个10呢  <strong>10 = 1 + 2 + 4 + 3，再</strong>比如7 就可以用 1 + 2 + 4来表示，只需要枚举3次。这就是我们二进制优化的思想。</p><p>比如：第一件物品有v[i]=2（体积）,w[i]=3（价值）,s[i]=12（数量）；可以拆分为：4件如下图所示的物品：（其实本质还是01背包，只不过这时候我们合并了一下，让其装的更快了）</p><p><img src="https://i-blog.csdnimg.cn/direct/5ca14df2e84e46b88575bcc906d1ad2a.png" alt="">​</p><p><img src="https://i-blog.csdnimg.cn/direct/6da2d39d2d2e48d5bda15a6e58bf2fee.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[<span class="number">2001</span>],n,V,v,w,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;<span class="comment">//第i个物品，体积，价值，个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s;k &lt;&lt;= <span class="number">1</span>)<span class="comment">// 以 k &lt;&lt;= 1 实际上是将 k 的值乘以 2。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= k*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*v]+k*w);<span class="comment">//把第i件多拆分成几件，再做01背包            &#125;</span></span><br><span class="line">            s -= k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = V;j &gt;= s*v;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = <span class="built_in">max</span>(dp[j],dp[j-s*v]+s*w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[V];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单调队列优化"><a href="#单调队列优化" class="headerlink" title="单调队列优化"></a>单调队列优化</h4><p><img src="https://i-blog.csdnimg.cn/direct/20ff0a9e87944a0c8cda69d98114f3f7.png" alt="">​</p><p> 本题题解来源：<a href="https://www.acwing.com/solution/content/53507/" title="AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing">AcWing 6. 多重背包问题 III【单调队列优化+图示】 - AcWing</a></p><p>按照完全背包的思路：我们列举如下：</p><p><img src="https://i-blog.csdnimg.cn/direct/750241a6c3644699b8b3aa039e6f9aa6.png" alt="">​</p><p>r表示j </p><p><img src="https://i-blog.csdnimg.cn/direct/ac046c2c569f4c49a0aba251274ea457.png" alt="">​</p><p>具体图示：</p><p><img src="https://i-blog.csdnimg.cn/direct/d922806b35db4606a7656b4970626cf0.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    时间复杂度的分析，我觉得通过代码很难看出来，</span></span><br><span class="line"><span class="comment">    可以通过它的计算过程以及它计算的大体次数来体会。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    比如总体积为V = 10,某个物品对应v=3</span></span><br><span class="line"><span class="comment">    以一个物品为例，我们计算的时候，是把这个物品按照对v取余的结果来分类的。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    v&#x27; = 0是一类，这一类有 0, 3, 6, 9      (v&#x27;表示当前正在求的体积)</span></span><br><span class="line"><span class="comment">    v&#x27; = 1是一类，这一类有 1, 4, 7, 10</span></span><br><span class="line"><span class="comment">    v&#x27; = 2是一类，这一类有 2, 5, 8</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    我们通过单调队列优化，只是在每一类中进行优化(滑动窗口求最值)</span></span><br><span class="line"><span class="comment">    对于每个物品，我们都会求一遍v&#x27; = 0 ~ v&#x27; = 10，只是再求的过程中把它们分类了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    一共n个物品，我们会对 物品1 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       对 物品2 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment">                       ....</span></span><br><span class="line"><span class="comment">                       对 物品n 求一遍  v&#x27; = 0 ~ v&#x27; = 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    总共实际求了 n * (v&#x27;的最大值)， 即 n*m次</span></span><br><span class="line"><span class="comment">    所以时间复杂度是O(n*m)的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20020</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], g[N], q[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> v, w, s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v, &amp;w, &amp;s);</span><br><span class="line">        <span class="built_in">memcpy</span>(g, f, <span class="keyword">sizeof</span> f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>;c &lt; v;c ++)&#123; <span class="comment">// 遍历余数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = c;j &lt;= m;j += v)&#123; <span class="comment">// 遍历余数为c这一类的 体积</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 当前层的f[j]  暂时等于 上一层的g[j]  相当于 f[i][j] = f[i-1][j];  也就是s = 0情况</span></span><br><span class="line">                f[j] = g[j]; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里一共有s+1个元素,s=0也算一个，所以这里不是j - s*v + 1</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; j - s*v &gt; q[hh]) hh ++; <span class="comment">// 队列存的是下标，也是体积 </span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 队列中最大的(s!=0的其中一个)  和 s=0的进行比较</span></span><br><span class="line">                <span class="keyword">if</span>(hh &lt;= tt) f[j] = <span class="built_in">max</span>(f[j], g[q[hh]] + (j-q[hh])/v*w); </span><br><span class="line"></span><br><span class="line">                <span class="comment">// q[tt]这个体积下的价值，再加上与j体积相差的体积数的价值，才能与g[j]进行对等比较   </span></span><br><span class="line">                <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; g[q[tt]] + (j - q[tt])/v*w &lt;= g[j]) tt --; </span><br><span class="line"></span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><h3 id="leetcode089-打家劫舍"><a href="#leetcode089-打家劫舍" class="headerlink" title="leetcode089.打家劫舍"></a>leetcode089.打家劫舍</h3><p><a href="https://leetcode.cn/problems/Gu0c2T/" title="089.打家劫舍">089.打家劫舍</a></p><p>用普通线性dp：</p><p>从0~i家店铺最大收益：dp[i]=max(dp[i-1],dp[i-2]+nums[i]);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">       <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>状态机思路：</p><p>引入两个状态：  </p><p>f(i)————&gt;f(i,0)（未选择最后一个店铺）</p><p>|                                  </p><p>|</p><p>-—————-&gt;f(i,1)（选择最后一个店铺）</p><p><img src="https://i-blog.csdnimg.cn/direct/814b9e0b3c1b439d8fdc22ee6760412c.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[nums.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/house-robber-ii/description/" title="213.打家劫舍2">213.打家劫舍2</a>（补充线性dp）</p><p>对打家劫舍1进行分类讨论，分为：选第一个，还是选最后一个，其他都是一模一样。分为0~n-2与1~n-1，两个部分，也就是考虑nums[0]，考虑nums[n-1]，这两个数的分类讨论。（因为选了0不能选n-1，选了n-1，不能选0）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">robrange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()<span class="number">+1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[l]=nums[l],dp[l<span class="number">+1</span>]=<span class="built_in">max</span>(nums[l],nums[l<span class="number">+1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l<span class="number">+2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">            dp[i]=<span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i],dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[r];</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robrange</span>(nums,<span class="number">0</span>,n<span class="number">-2</span>),<span class="built_in">robrange</span>(nums,<span class="number">1</span>,n<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买股票的最佳时机4"><a href="#leetcode买股票的最佳时机4" class="headerlink" title="leetcode买股票的最佳时机4"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="leetcode买股票的最佳时机4">leetcode买股票的最佳时机4</a></h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/" title="买股票的最佳时机4">买股票的最佳时机4</a></p><p><img src="https://i-blog.csdnimg.cn/direct/768d8f15245f4acbab273a9ba996d550.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在这个基础上，我们直接搞定前面的几道股票题：</p><h3 id="leetcode121-买卖股票的最佳时机"><a href="#leetcode121-买卖股票的最佳时机" class="headerlink" title="leetcode121. 买卖股票的最佳时机"></a>leetcode121. 买卖股票的最佳时机</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" title="121. 买卖股票的最佳时机">121. 买卖股票的最佳时机</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , -prices[i]);//因为限定交易次数为1，只能交易1次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , -prices[i]);<span class="comment">//因为限定交易次数为1，只能交易1次</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode122-买卖股票的最佳时机-2"><a href="#leetcode122-买卖股票的最佳时机-2" class="headerlink" title="leetcode122. 买卖股票的最佳时机 2"></a>leetcode122. 买卖股票的最佳时机 2</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/" title="122. 买卖股票的最佳时机 II">122. 买卖股票的最佳时机 II</a></p><p>变化：</p><blockquote><p> dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]);<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i]);//无限交易次数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode123-买卖股票的最佳时机-3"><a href="#leetcode123-买卖股票的最佳时机-3" class="headerlink" title="leetcode123. 买卖股票的最佳时机 3"></a>leetcode123. 买卖股票的最佳时机 3</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/" title="123. 买卖股票的最佳时机 III">123. 买卖股票的最佳时机 III</a></p><p>变化：</p><blockquote><p> int k=2;即可，其他均不变</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> k=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">( vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(k<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">-1e9</span>)));</span><br><span class="line">        <span class="comment">//dp[prices.size()+1][k+1][2];</span></span><br><span class="line">        <span class="comment">//考虑0次交易</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=prices.<span class="built_in">size</span>();i++) dp[i][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//dp[i][0][1]=-1e9;表示状态不合法</span></span><br><span class="line">        <span class="comment">//考虑有交易</span></span><br><span class="line">        <span class="comment">//dp[0][1][0]=-1e9;</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">0</span>],dp[i<span class="number">-1</span>][j][<span class="number">1</span>]+prices[i]);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j][<span class="number">1</span>],dp[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) res=<span class="built_in">max</span>(res,dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][i][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含冷冻期"><a href="#leetcode买卖股票的最佳时机含冷冻期" class="headerlink" title="leetcode买卖股票的最佳时机含冷冻期"></a>leetcode买卖股票的最佳时机含冷冻期</h3><p> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/" title="买卖股票的最佳时间含冷冻期">买卖股票的最佳时间含冷冻期</a></p><p> <img src="https://i-blog.csdnimg.cn/direct/065ce52db1824441a7093d0aacc51f07.png" alt="">​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];<span class="comment">//第0天买入</span></span><br><span class="line">        <span class="comment">//dp[0][2]=-1e9;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>]=dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode买卖股票的最佳时机含手续费"><a href="#leetcode买卖股票的最佳时机含手续费" class="headerlink" title="leetcode买卖股票的最佳时机含手续费"></a>leetcode买卖股票的最佳时机含手续费</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" title="买卖股票的最佳时机含手续费">买卖股票的最佳时机含手续费</a></p><blockquote><p>与股票2完全一样，</p><p>dp[i][0]=max(dp[i-1][0] , dp[i-1][1]+prices[i]-fee) //卖出股票时完成一次交易，支付手续费<br>dp[i][1]=max(dp[i-1][1] , dp[i-1][0]-prices[i])</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> inf=<span class="number">-1e9</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>()<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,inf));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;prices.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] , dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee);</span><br><span class="line">            dp[i][<span class="number">1</span>]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>] , dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);<span class="comment">//无限交易次数</span></span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">max</span>(dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>],dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="leetcode-打家劫舍3"><a href="#leetcode-打家劫舍3" class="headerlink" title="leetcode 打家劫舍3"></a>leetcode 打家劫舍3</h3><p><a href="https://leetcode.cn/problems/house-robber-iii/description/" title="打家劫舍3">打家劫舍3</a></p><p>dp数组（这里写成PII）的含义：first记录不偷该节点所得到的的最大金钱，second记录偷该节点所得到的的最大金钱。</p><p>首先明确的是使用后序遍历。 因为要通过递归函数的返回值来做下一步计算。</p><p>通过递归左节点，得到左节点偷与不偷的金钱。</p><p>通过递归右节点，得到右节点偷与不偷的金钱。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        PII r=<span class="built_in">robTree</span>(root);</span><br><span class="line">        <span class="type">int</span> result=<span class="built_in">max</span>(r.first,r.second);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">PII <span class="title">robTree</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">            PII l=<span class="built_in">robTree</span>(root-&gt;left);</span><br><span class="line">            PII r=<span class="built_in">robTree</span>(root-&gt;right);</span><br><span class="line">            <span class="type">int</span> rob_yes=root-&gt;val+l.first+r.first;</span><br><span class="line">            <span class="type">int</span> rob_not=<span class="built_in">max</span>(l.second,l.first)+<span class="built_in">max</span>(r.first,r.second);<span class="comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span></span><br><span class="line">            <span class="keyword">return</span> &#123;rob_not,rob_yes&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树的直径"><a href="#leetcode二叉树的直径" class="headerlink" title="leetcode二叉树的直径"></a>leetcode二叉树的直径</h3><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/" title="二叉树的直径">二叉树的直径</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">int</span> re=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">find</span>(root-&gt;left)<span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">find</span>(root-&gt;right)<span class="number">+1</span>;</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="leetcode二叉树中的最大路径和"><a href="#leetcode二叉树中的最大路径和" class="headerlink" title="leetcode二叉树中的最大路径和"></a>leetcode二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/" title="二叉树中的最大路径和">二叉树中的最大路径和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> re=<span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxTreeReturnlrAndSum</span><span class="params">(TreeNode*root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> r=<span class="built_in">maxTreeReturnlrAndSum</span>(root-&gt;right);</span><br><span class="line">        re=<span class="built_in">max</span>(re,l+r+root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(l+root-&gt;val,r+root-&gt;val),<span class="number">0</span>);<span class="comment">//由于返回值会有负数，所以我们还需要和0，取一个最大值，因为如果是负数，我们可以选择不要</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><h3 id="小国王"><a href="#小国王" class="headerlink" title="小国王"></a>小国王</h3><p><a href="https://blog.csdn.net/m0_64226820/article/details/126199603?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224A577738-06E0-411F-B41D-A1C6B261F777%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=4A577738-06E0-411F-B41D-A1C6B261F777&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-126199603-null-null.142%5Ev100%5Epc_search_result_base5&amp;utm_term=%E7%8A%B6%E5%8E%8Bdp&amp;spm=1018.2226.3001.4187" title="状态压缩DP 图文详解（一）_状压dp-CSDN博客">状态压缩DP 图文详解（一）_状压dp-CSDN博客</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"> </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  K = <span class="number">110</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state;</span><br><span class="line"><span class="type">int</span> cnt[M]; <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; head[M];<span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">LL f[N][K][M]; <span class="comment">//状态转移方程，存方案数</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="comment">//同一行两个国王不能相邻</span></span><br><span class="line">        <span class="keyword">if</span>((state &gt;&gt; i &amp; <span class="number">1</span>) &amp;&amp; (state &gt;&gt; i + <span class="number">1</span> &amp; <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> state)</span> <span class="comment">//统计该状态下国王，即1的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += state &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt;n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//预处理所有合法状态 (对于这两个状态压缩有疑惑的，看看上面的图)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">        &#123;</span><br><span class="line">            state.<span class="built_in">push_back</span>(i); <span class="comment">//将合法方案存入state</span></span><br><span class="line">            cnt[i] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//预处理所有合法状态的合法转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; state.<span class="built_in">size</span>();i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; state.<span class="built_in">size</span>();j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = state[i], b = state[j];</span><br><span class="line">            <span class="keyword">if</span>((a &amp; b) == <span class="number">0</span> &amp;&amp; <span class="built_in">check</span>(a | b)) <span class="comment">//a &amp; b 指第i行和i-1行不能在同列有国王， check(a|b) == 1 指i和i -1行不能相互攻击到</span></span><br><span class="line">                head[i].<span class="built_in">push_back</span>(j);  <span class="comment">//head[i] 里存储在第i行状态为state[a]的情况下，上一行状态可以取到的合法状态statep[b]</span></span><br><span class="line">        &#125;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//求方案数时，初始方案需要为1,因为全部空 也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n + <span class="number">1</span>;i ++) <span class="comment">//枚举每一行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= m;j ++) <span class="comment">//国王数量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>;a &lt; state.<span class="built_in">size</span>();a ++) <span class="comment">//枚举合法方案</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> b : head[a])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> c = cnt[state[a]];  <span class="comment">//状态state[a]的国王个数</span></span><br><span class="line">                    <span class="keyword">if</span>(j &gt;= c)</span><br><span class="line">                        f[i][j][state[a]] += f[i - <span class="number">1</span>][j - c][state[b]]; <span class="comment">//f[i][state[a]], 在第i行状态为i时，所有i - 1行的状态数量</span></span><br><span class="line">                    <span class="comment">//因为state[a]和a呈映射关系，所也可以写成</span></span><br><span class="line">                    <span class="comment">//  f[i][j][a] += f[i - 1][j - c][b];</span></span><br><span class="line">                &#125;</span><br><span class="line">        cout &lt;&lt; f[n + <span class="number">1</span>][m][<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//我们假设摆到n + 1行，并且另这一行状态为0,那么即得到我们想要的答案， </span></span><br><span class="line">    <span class="comment">//如果我们用f[n][m][]来获取答案，那么我们就要枚举最后一行的所有状态取最大值，来得到答案。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="leetcode-647-回文子串"><a href="#leetcode-647-回文子串" class="headerlink" title="leetcode 647. 回文子串"></a>leetcode 647. 回文子串</h3><p><a href="https://baijiahao.baidu.com/s?id=1801374813549433140&amp;wfr=spider&amp;for=pc" title="leetcode 647. 回文子串">leetcode 647. 回文子串</a></p><blockquote><p>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。 </p><p>当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。</p><p>当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况</p><ul><li>情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串</li><li>情况二：下标i 与 j相差为1，例如aa，也是回文子串</li><li>情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。</li></ul><p><strong>遍历顺序：</strong></p><p><img src="https://i-blog.csdnimg.cn/direct/aaa7bfad9bb1431680974ca2d6404d88.png" alt=""></p><p><strong>所以一定要从下到上，从左到右遍历，这样保证dp[i + 1][j - 1]都是经过计算的</strong>。</p></blockquote><p> java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想知道最长的回文串长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">         <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()+<span class="number">1</span>][s.length()+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;s.length();j++)&#123;<span class="comment">//一定要j&gt;i</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j) )&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;<span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j - i ==<span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j - <span class="number">1</span>]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">         <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;s.length();k++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;s.length();l++)&#123;</span><br><span class="line">                    res=Math.max(res,dp[k][l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/palindromic-substrings/solutions/379987/hui-wen-zi-chuan-by-leetcode-solution/" title=".  - 力扣（LeetCode）">. - 力扣（LeetCode）</a></p><p>其他方法|</p><h3 id="leetcode-516-最长回文子序列"><a href="#leetcode-516-最长回文子序列" class="headerlink" title="leetcode 516. 最长回文子序列"></a>leetcode 516. 最长回文子序列</h3><p><a href="https://leetcode.cn/problems/longest-palindromic-subsequence/description/" title="leetcode 516. 最长回文子序列">leetcode 516. 最长回文子序列</a></p><blockquote><p><strong>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]</strong>。</p><p>在判断回文子串的题目中，关键逻辑就是看s[i]与s[j]是否相同。</p><p>如果s[i]与s[j]相同，那么dp[i][j] = dp[i + 1][j - 1] + 2;</p><p>如果s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子序列的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</p><p>加入s[j]的回文子序列长度为dp[i + 1][j]。</p><p>加入s[i]的回文子序列长度为dp[i][j - 1]。</p><p>那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);</p><p><img src="https://i-blog.csdnimg.cn/direct/95ec8fff8e5649d6ac0cdfb5b27a9b26.png" alt=""></p><p>首先要考虑当i 和j 相同的情况，从递推公式：dp[i][j] = dp[i + 1][j - 1] + 2; 可以看出 递推公式是计算不到 i 和j相同时候的情况。</p><p>所以需要手动初始化一下，当i与j相同，那么dp[i][j]一定是等于1的，即：一个字符的回文子序列长度就是1。</p><p>其他情况dp[i][j]初始为0就行，这样递推公式：dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); 中dp[i][j]才不会被初始值覆盖。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            dp[i][i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==s.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/10/07/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>定义：一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。</p></blockquote><p><strong>一个有N个点的图，边一定是大于等于N-1条的。图的最小生成树，就是在这些边中选择N-1条出来，连接所有的N个点。这N-1条边的边权之和是所有方案中最小的。</strong></p><p>通俗的来讲：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。</p><p>如果要求一个图的最小生成树，可以用prim和kruskal算法</p><h2 id="1-prim"><a href="#1-prim" class="headerlink" title="1.prim"></a>1.prim</h2><p>类似于dijkstra算法</p><blockquote><p>int dist[n],state[n],pre[n];<br>dist[1] = 0;<br>for(i : 1 ~ n)<br>{<br>    t &lt;- 没有连通起来，但是距离连通部分最近的点;<br>    state[t] = 1;<br>    更新 dist 和 pre;<br>}</p></blockquote><p>参考之前的代码，我们不难得到：（带注释）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>  res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j]&amp;&amp;(t == <span class="number">-1</span> || dis[t] &gt; dis[j]))&#123;</span><br><span class="line"><span class="comment">//j不在集合中，找到最小dis</span></span><br><span class="line">                t=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>&amp;&amp;dis[t]==INF) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="comment">//i不是第一个点，如果最短的dis为INF，说明不联通，没有最短路，直接返回</span></span><br><span class="line">        res+=dis[t];<span class="comment">//累积求和</span></span><br><span class="line">        st[t]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            dis[j]=<span class="built_in">min</span>(dis[j],g[t][j]);</span><br><span class="line"><span class="comment">//与dijkstra不同，这里不需要dis[t]+g[t][j]应为我们是累加，而不是求每一个点到第一点的最短距离。    </span></span><br><span class="line"> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//注意是无向边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了之前的经验，我们直到，这里也可以用堆优化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL ,LL &gt;PII;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line">LL n,m,resmax;</span><br><span class="line">LL e[N],ne[N],w[N],idx=<span class="number">0</span>,h[N];</span><br><span class="line">LL res[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,LL ww)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b,ne[idx]=h[a],w[idx]=ww,h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(res,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> res);</span><br><span class="line">    res[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(st[t.second]) <span class="keyword">continue</span>;</span><br><span class="line">        st[t.second]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t.second];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> k=e[i];</span><br><span class="line">            <span class="keyword">if</span>(res[k]&gt;w[i]&amp;&amp;!st[k])</span><br><span class="line">            &#123;</span><br><span class="line">                res[k]=w[i];<span class="comment">//这一块不太一样</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;res[k],k&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a,b,ww;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;ww;</span><br><span class="line">        <span class="built_in">add</span>(a,b,ww);</span><br><span class="line">        <span class="built_in">add</span>(b,a,ww);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        resmax=resmax+res[i];</span><br><span class="line">        <span class="keyword">if</span>(res[i]&gt;<span class="number">0x3f3f3f3f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;resmax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-kruskal"><a href="#2-kruskal" class="headerlink" title="2.kruskal"></a>2.kruskal</h2><p>思路非常简单，算法实现类似于之前的并查集。</p><blockquote><p><strong>算法思路：</strong></p><p>将所有边按照权值的大小进行升序排序，然后从小到大一一判断。</p><p>如果这个边与之前选择的所有边不会组成回路，就选择这条边分；反之，舍去。</p><p>直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。</p><p>筛选出来的边和所有的顶点构成此连通网的最小生成树。</p><p><strong>判断是否会产生回路的方法为：使用并查集。</strong></p><p>在初始状态下给各个个顶点在不同的集合中。</p><p>遍历过程的每条边，判断这两个顶点的是否在一个集合中。</p><p>如果边上的这两个顶点在一个集合中，说明两个顶点已经连通，这条边不要。如果不在一个集合中，则要这条边。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    <span class="comment">//重载运算符</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge&amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a,b=edges[i].b,w=edges[i].w;</span><br><span class="line">        <span class="type">int</span> ra=<span class="built_in">find</span>(a),rb=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(ra!=rb)&#123;</span><br><span class="line">            p[ra]=rb;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果重载运算符不理解可以换成：</p><p>bool cmp(struct Edge A, struct Edge B)<br>{<br>return A.w &lt; B.w;<br>}<br>然后sort里加个参数 ： sort(edges, edges + m,cmp);</p>]]></content>
      
      
      <categories>
          
          <category> 代码笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
